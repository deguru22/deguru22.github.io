<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ARM 어셈블리 튜토리얼 (4) 메모리 명령어: 불러오기 및 저장 | 데구루루x2 놀이터</title><meta name=keywords content="ARM,Assembly,Tutorial"><meta name=description content="ARM 어셈블리 기본 내용"><meta name=author content="deguru22"><link rel=canonical href=https://deguru22.github.io/2021/09/19/arm-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-4-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0-%EB%B0%8F-%EC%A0%80%EC%9E%A5/><link crossorigin=anonymous href=/assets/css/stylesheet.min.5e2b4101351c21e906f398ae96901791830f58d430f96f2659dab7eaef7b3cb7.css integrity="sha256-XitBATUcIekG85iulpAXkYMPWNQw+W8mWdq36u97PLc=" rel="preload stylesheet" as=style><link rel=preload href=/images/deguru22.jpg as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://deguru22.github.io/ico/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://deguru22.github.io/ico/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://deguru22.github.io/ico/favicon-32x32.png><link rel=apple-touch-icon href=https://deguru22.github.io/ico/apple-touch-icon.png><link rel=mask-icon href=https://deguru22.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.98.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-164568875-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="ARM 어셈블리 튜토리얼 (4) 메모리 명령어: 불러오기 및 저장"><meta property="og:description" content="ARM 어셈블리 기본 내용"><meta property="og:type" content="article"><meta property="og:url" content="https://deguru22.github.io/2021/09/19/arm-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-4-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0-%EB%B0%8F-%EC%A0%80%EC%9E%A5/"><meta property="og:image" content="https://deguru22.github.io/static/deguru22.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-19T16:52:34+09:00"><meta property="article:modified_time" content="2021-09-19T16:52:34+09:00"><meta property="og:site_name" content="데구루루x2 놀이터"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://deguru22.github.io/static/deguru22.jpg"><meta name=twitter:title content="ARM 어셈블리 튜토리얼 (4) 메모리 명령어: 불러오기 및 저장"><meta name=twitter:description content="ARM 어셈블리 기본 내용"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://deguru22.github.io/posts/"},{"@type":"ListItem","position":2,"name":"ARM 어셈블리 튜토리얼 (4) 메모리 명령어: 불러오기 및 저장","item":"https://deguru22.github.io/2021/09/19/arm-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-4-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0-%EB%B0%8F-%EC%A0%80%EC%9E%A5/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ARM 어셈블리 튜토리얼 (4) 메모리 명령어: 불러오기 및 저장","name":"ARM 어셈블리 튜토리얼 (4) 메모리 명령어: 불러오기 및 저장","description":"ARM 어셈블리 기본 내용","keywords":["ARM","Assembly","Tutorial"],"articleBody":"ARM Assembly에 대해 공부하던 중 좋은 글이 있어 번역 하였다.\n출처: Azeria Labs (https://azeria-labs.com/writing-arm-assembly-part-4/)\n ARM은 메모리 접근 시 오직 불러오기-저장(load-store, LDR and STR) 명령만을 사용 하도록 하는 불러오기-저장 모델을 사용합니다. x86에서 대부분의 명령들은 직접 메모리 안의 데이터를 접근하는 것과 달리, ARM에서는 데이터는 반드시 처리 전에 레지스터로 불러오는 과정을 거쳐야 합니다. 이 말인 즉슨 특정 메모리에 올라와 있는 32-bit 값을 ARM에서 증가 시키려면 3개의 명령어(불러오기, 증가하기, 저장)를 실행 해야 한다는 이야기 입니다.\nARM에서의 불러오기와 저장 명령의 기본을 설명하기 전에, 기본적인 예제들과 세가지 오프셋 폼, 그리고 각각의 오프셋 폼 별 존재하는 세가지 주소 모드를 배울겁니다. 각각의 예제에서는 같은 어셈블리 명령어에 다른 LDR/STR 오프셋 폼을 사용하여 단순하게 할것입니다. 이 튜토리얼을 잘 이해하기 위해서는 GDB에서 직접 실행해 보면 좋습니다.\n\n 오프셋 폼: 직접 입력한 값을 오프셋으로  주소 모드: 오프셋 주소 모드: Pre-Indexed 주소 모드: Post-Indexed   오프셋 폼: 레지스터를 오프셋으로  주소 모드: 오프셋 주소 모드: Pre-Indexed 주소 모드: Post-Indexed   오프셋 폼: 스케일된 레지스터를 오프셋으로  주소 모드: 오프셋 주소 모드: Pre-Indexed 주소 모드: Post-Indexed    첫 번째 단순한 예제 일반적으로 LDR은 메모리에서 레지스터로 값을 불러올 때 사용하며, STR은 레지스터의 값을 특정 메모리 주소에 저장할 때 사용합니다.\nLDR R2, [R0] @ [R0] - R0의 값이 메모리 주소 STR R2, [R1] @ [R1] - R1의 값이 메모리 주소  LDR 명령어: R0가 갖고있는 메모리 주소에 위치하고 있는 값을 R2에 저장 STR 명령어: R2가 갖고있는 값을 메모리에 저장  어셈블리 프로그램으로 작성한 프로그램은 아래와 같습니다.\n.data /* .data section 은 자동으로 생기며 위치를 알기 매우 쉬움 */ var1: .word 3 /* 메모리 안에 있는 variable 1 */ var2: .word 4 /* 메모리 안에 있는 variable 2 */  .text /* 코드 섹션 시작점 */ .global _start  _start:  ldr r0, adr_var1 @ var1 메모리 주소를 label adr_var1 통해 R0에 저장  ldr r1, adr_var2 @ var2 메모리 주소를 label adr_var2 통해 R1에 저장  ldr r2, [r0] @ R0에서 가져온 값(0x03)을 R2 위치에 저장  str r2, [r1] @ R2에서 가져온 값(0x03)을 R1 위치에 저장  bkpt  adr_var1: .word var1 /* var1 주소 저장 */ adr_var2: .word var2 /* var2 주소 저장 */ 위 코드의 아래쪽에 우리의 리터럴 풀(Literal Pool, 코드 섹션과 동일한 메모리 공간으로 상수, 문자열, 오프셋 등을 포지션과 관계없이 저장 및 사용하기 위해 사용)이 있는데, data 섹션에 있는 var1과 var2의 메모리 주소를 저장하기 위해 사용했습니다. var1, var2의 값이 저장된 주소를 adr_var1, adr_var2로 저장했습니다. 첫번째 LDR은 var1의 주소를 레지스터 R0에 저장합니다. 두번째 LDR은 var2의 주소를 레지스터 R1에 저장합니다. 그 후 R0에 저장된 메모리 주소를 통해 해당 메모리에 저장되어 있는 값을 R2에 불러옵니다. R2에 불러온 값은 R1에 저장되어있는 메모리 주소에 기록합니다.\n우리가 레지스터에 뭔가를 불러올 때, 중괄호([ ])의 의미는 우리가 뭔가를 불러오기 위한 메모리 주소를 뜻합니다.\n우리가 뭔가를 메모리 주소에 저장할 때, 중괄호([ ])의 의미는 우리가 뭔가를 저장할 때 사용할 메모리 주소를 뜻합니다.\n이러한 내용들이 실제 내용보다 복잡해 보이니까, 텍스트가 아닌 구체적인 사례를 보면서 어떻게 메모리에서 값을 불러오고 저장하는지 알아봅시다.\n같은 코드를 디버거에서 보면 아래와 같습니다.\ngef disassemble _start Dump of assembler code for function _start:  0x00008074 0: ldr r0, [pc, #12] ; 0x8088 adr_var1  0x00008078 4: ldr r1, [pc, #12] ; 0x808c adr_var2  0x0000807c 8: ldr r2, [r0]  0x00008080 12: str r2, [r1]  0x00008084 16: bx lr End of assembler dump. 위 두 개의 LDR 명령을 보면, 레이블들이 [pc, #12]로 바뀌었습니다. 이러한 형태를 PC-관련 주소(PC-Relative addressing)라고 합니다. 우리가 레이블을 사용했기때문에 컴파일러가 리터럴 풀에서 값을 특정할 수 있습니다(PC+12). 이 값을 직접 계산할 수도 있고, 아니면 레이블을 사용할 수도 있습니다. 두 개의 유일한 차이점은, 당신이 수동으로 포지션을 계산 하느냐 마느냐 입니다. PC-관련 주소에 대한 자세한 내용은 이 챕터의 아래쪽에서 다루도록 하겠습니다.\n추가 노트: 만약 왜 effective PC가 현재의 PC에서 왜 2개의 명령어를 앞서 있는지를 까먹었다면, Part 2를 복습하세요. 복습하기 귀찮다면… PC는 현재 주소에서 더하기 8(ARM 기준) 혹은 4(Thumb 기준)해서 저장되기 때문입니다.\n1. 오프셋 폼: 값을 직접 오프셋으로 사용 STR Ra, [Rb, imm] LDR Ra, [Rc, imm] 위의 예제는 값(숫자)을 직접 오프셋으로 사용하는 경우입니다. 해당 값을 베이스 레지스터에서 더하거나 뺀 후 메모리 접근 시 사용합니다. 오프셋 값은 컴파일 시 결정됩니다.\n.data var1: .word 3 var2: .word 4  .text .global _start  _start:  ldr r0, adr_var1 @ var1의 메모리 주소를 adr_var1에서 가져와서 R0에 저장  ldr r1, adr_var2 @ var2의 메모리 주소를 adr_var2에서 가져와서 R1에 저장  ldr r2, [r0] @ R0에 저장된 메모리 주소 저장돼 있는 값(0x03)을 R2에 저장  str r2, [r1, #2] @ 주소 모드: R2에 저장된 값(0x03)을 R1에 저장된 메모리 값 + 2 위치에 저장함. 베이스 레지스터(R1) 값에는 변동 없음  str r2, [r1, #4]! @ 주소 모드: pre-indexed. R2에 저장된 값(0x03)을 R1에 저장된 메모리 값 + 4에 저장함. 베이스 레지스터(R1) 변동: R1 = R1+4  ldr r3, [r1], #4 @ 주소 모드: post-indexed. R1에 저장된 메모리 주소 내의 값을 R3에 저장함. 베이스 레지스터(R1) 변경됨: R1=R1+4  bkpt  adr_var1: .word var1 adr_var2: .word var2 위 프로그램을 ldr.s로 저장하고 컴파일 후 GDB에서 실행하면 어떻게 되는지 봅시다.\n$ as ldr.s -o ldr.o $ ld ldr.o -o ldr $ gdb ldr GDB(gef 설치된 버전)에서 _start에 breakpoint를 걸고 프로그램을 실행해 봅시다.\ngef break _start gef run ... gef nexti 3 /* 다음 3개 명령 실행 */ 레지스터들이 아래 값으로 채워진 것을 확인할 수 있습니다(값은 시스템 별로 상이할 수 있으니 참고하세요).\n$r0 : 0x00010098 - 0x00000003 $r1 : 0x0001009c - 0x00000004 $r2 : 0x00000003 $r3 : 0x00000000 $r4 : 0x00000000 $r5 : 0x00000000 $r6 : 0x00000000 $r7 : 0x00000000 $r8 : 0x00000000 $r9 : 0x00000000 $r10 : 0x00000000 $r11 : 0x00000000 $r12 : 0x00000000 $sp : 0xbefff7e0 - 0x00000001 $lr : 0x00000000 $pc : 0x00010080 - _start+12 str r2, [r1] $cpsr : 0x00000010 다음에 실행될 명령어는 오프셋 주소 모드의 STR 명령입니다. 이 명령은 R2의 값(0x3)을 R1이 저장하고 있는 메모리 주소(0x1009c) + 오프셋(#2) = 0x1009e 위치에 저장할 것입니다.\ngef nexti gef x/w 0x1009e 0x1009e var2+2: 0x3 다음 STR 명령은 pre-indexed 주소 모드를 사용합니다. 이 모드 적용 여부는 느낌표(!)를 통해 알 수 있습니다. 이 모드의 다른점은 베이스 레지스터가 R2의 값이 저장될 최종 메모리 주소로 업데이트 된다는 점입니다. 이 말인 즉슨, 우리는 R2에 저장된 값(0x3)을 R1이 가지고 있는 메모리 주소(0x1009c) + 오프셋(#4) = 0x100A0에 저장하고, R1을 이 주소(0x100A0)로 업데이트 한다는 것이죠.\ngef nexti gef x/w **0x100A0** **0x100a0**: 0x3 gef info register r1 r1 **0x100a0** 65696 마지막 LDR 명령은 post-indexed 주소 모드를 사용합니다. 이 모드는 베이스 레지스터(R1)을 최종 주소로 사용하고, 오프셋을 계산(R1+4) 후 해당 값을 업데이트 합니다. 이 말인 즉슨, R1+4가 아니라 R1(0x100A0)에 저장된 값을 찾아서 R3에 불러옵니다. 그 후 R1을 R1(0x100A0) + 오프셋(#4) = 0x100A4 로 업데이트 합니다.\ngef info register r1 r1 **0x100a4** 65700 gef info register r3 r3 **0x3** 3 아래에 위 과정을 그림으로 표현해 보았습니다.\n2. 오프셋 폼: 레지스터를 오프셋으로 사용 STR Ra, [Rb, **Rc**] LDR Ra, [Rb, **Rc**] 이 오프셋 폼은 레지스터를 오프셋으로 사용합니다. 이러한 오프셋 폼은 코드 내에서 런타임에 인덱스를 계산해서 배열을 접근할 때 사용합니다.\n.data var1: .word 3 var2: .word 4  .text .global _start  _start:  ldr r0, adr_var1 @ adr_var1에 저장된 var1의 메모리 주소를 R0에 저장  ldr r1, adr_var2 @ adr_var2에 저장된 var2의 메모리 주소를 R1에 저장  ldr r2, [r0] @ R0에 저장된 메모리 주소에서 가져온 값(0x03)을 Offset R2에 저장  str r2, [r1, r2] @ 주소 모드: 오프셋. R2에 저장된 값(0x03)을 R1에 저장된 메모리 주소에 오프셋 R2(0x03)을 포함하여 저장. 베이스 레지스터 변동 없음.  str r2, [r1, r2]! @ 주소 모드: pre-indexed. R2에 저장된 값(0x03)을 R1에 저장된 메모리 주소에 오프셋 R2(0x03)을 포함하여 저장. 베이스 레지스터 변경: R1=R1+R2  ldr r3, [r1], r2 @ 주소 모드: post-indexed. R1에 저장된 메모리 주소에 존재하는 값을 R3에 불러옴. 베이스 레지스터 변동: R1=R1+R2  bx lr  adr_var1: .word var1 adr_var2: .word var2 오프셋 주소 모드로 첫번째 STR 명령을 실행 하면, R2의 값 (0x3)이 메모리 주소(0x1009c + 0x3 = 0x1009F)에 저장됨\ngef x/w 0x0001009F 0x1009f var2+3: 0x00000003 두 번째 STR 명령은 pre-indexed 주소 모드로 위와 같은 결과를 가지지만, 차이점은 베이스 레지스터(R1)을 계산한 메모리 값(R1+R2)으로 변경 하는 점이 있습니다.\ngef info register r1 r1 **0x1009f** 65695 마지막 LDR 명령은 post-indexed 주소 모드로 R1에서 찾은 메모리 주소의 값을 R2로 불러온 후에 베이스 레지스터 R1을 업데이트(R1+R2 = 0x1009f + 0x3 = 0x100a2) 합니다.\ngef info register r1 r1 0x100a2 65698 gef info register r3 r3 0x3 3 3. 오프셋 폼: 스케일된 레지스터를 오프셋으로 사용 LDR Ra, [Rb, **Rc, shifter**] STR Ra, [Rb, **Rc, shifter**] 세 번째 오프셋 폼은 스케일된 레지스터를 오프셋으로 가집니다. 위의 폼에서 Rb는 베이스 레지스터이고 Rc는 직접 값 오프셋(혹은 값을 가진 레지스터)을 기반으로 오른쪽/왼쪽 쉬프팅된() 값입니다. 이 말인 즉슨, 배럴 쉬프터가 오프셋 스케일링에 사용됐다는 이야기 입니다. 이 오프셋을 사용하는 예는 배열 값을 순차적으로 접근할 때 입니다. 아래에 GDB를 통해 실행하는 예제를 참고해 주세요.\n.data var1: .word 3 var2: .word 4  .text .global _start  _start:  ldr r0, adr_var1  ldr r1, adr_var2  ldr r2, [r0]  str r2, [r1, r2, LSL#2]  str r2, [r1, r2, LSL#2]!  ldr r3, [r1], r2, LSL#2  bkpt  adr_var1: .word var1 adr_var2: .word var2 첫번째 STR 명령은 오프셋 주소 모드를 사용하여 R2 내의 값을 특정 메모리 주소([r1, r2, LSL#2] 연산 결과)에 기록합니다. 메모리 주소를 계산해 보면, R1의 값을 베이스로 사용(이 경우에는 R1에 var2의 주소값이 들어 있음)하고, R2의 값(0x3)을 가져와서 왼쪽으로 2번 쉬프팅을 합니다. 아래 그림을 통해 어떻게 메모리 주소가 계산되는지 보겠습니다.\n두번째 STR 명령은 pre-indexed 주소 모드를 사용합니다. 이 말은, 이전 명령과 동일한 명령을 수행하지만, 다른점은 R1을 계산한 메모리 주소 값으로 변경하는 점입니다. 다른 말로 얘기하자면, 메모리 주소(R1(0x1009c) + 왼쪽 오프셋으로 #2만큼 옮겨진(0x03 LSL#2 = 0xC) = 0x100a8)에 값을 저장한 후 R1을 0x100a8로 업데이트 합니다.\ngef info register r1 r1 **0x100a8** 65704 마지막 LDR 명령은 post-indexed 주소 모드를 사용합니다. 이 말은, R1(0x100a8)에 저장된 메모리 주소 내의 값을 R3에 저장한 후 베이스 레지스터인 R1을 계산한 값(R1(0x100a8) + R2 오프셋(0x3)을 왼쪽으로 #2 만큼 쉬프팅한 값 (0xC)=0x100b4) 으로 변경합니다.\ngef info register r1 r1 **0x100b4** 65716 정리 LDR/STR에는 세가지의 오프셋 모드가 있습니다.\n 직접 값을 오프셋으로 사용하는 경우  ldr r3, [r1, #4]   레지스터를 오프셋으로 사용하는 경우  ldr r3, [r1, r2]   스케일된 레지스터를 오프셋으로 사용하는 경우  ldr r3, [r1, r2, LSL#2]    LDR/STR의 다양한 모드를 기억하는 방법은 아래와 같습니다.\n 만약 **!**가 있다면 prefix 주소 모드  ldr r3, [r1, #4]! ldr r3, [r1, r2]! ldr r3, [r1, r2, LSL#2]!   만약 **베이스 레지스터가 **로 감싸져 있다면, postfix 주소 모드  ldr r3, [r1], #r ldr r3, [r1], r2 ldr r3, [r1], r2, LSL#2   다른거는 오프셋 주소 모드  ldr r3, [r1, #4] ldr r3, [r1, r2] ldr r3, [r1, r2, LSL#2]    PC 기반 주소의 LDR LDR은 단순히 메모리의 값을 레지스터로 옮기는데만 사용되지 않습니다. 가끔 아래와 같은 문법을 볼 수 있는데요…\n.section .text .global _start  _start:  ldr r0, =jump /* load the address of the function label jump into R0 */  ldr r1, =0x68DB00AD /* load the value 0x68DB00AD into R1 */ jump:  ldr r2, =511 /* load the value 511 into R2 */  bkpt 이러한 명령어들은 “의사 명령어(pseudo-instructions)” 라고 부릅니다. 우리는 이 명령어 문법을 리터럴 풀에 있는 데이터를 참조하기 위해 사용합니다. 리터럴 풀은 같은 섹션에 있는 메모리 공간(왜냐하면 리터럴 풀은 코드의 일부이기 때문입니다)으로, 상수나 문자열, 오프셋 등을 저장하기 위해 사용합니다. 위의 예제에서는 의사 명령어를 사용해서 함수의 오프셋을 참조하기 위해 사용하고, 하나의 명령을 통해 32-bit 상수를 레지스터로 옮기는데에 사용됩니다. 왜냐하면 ARM은 8-bit 값만 한번에 불러올 수 있기 때문입니다. 뭐라고요?! 왜 그런지를 이해하기 위해서는, 어떻게 ARM이 값(Immediate Values)을 핸들링 하는지 알아야 합니다.\nARM에서의 값(Immediate Values) 사용 ARM 에서 레지스터에 값을 로드하는 것은 x86처럼 직관적이지 않습니다. 값을 사용할 때 제약사항이 있습니다. 어떠한 제약사항이 있으며 어떻게 해결 해야하는지가 ARM 어셈블리의 가장 재밌는 부분이며, 이러한 제약 사항을 어떻게 해결해야 하는지에 대한 팁들을 아래에 기술해 두었습니다(힌트: LDR).\n우리는 각각의 ARM 명령어가 32-bit인걸 알고 있으며, 모든 명령어는 조건기반입니다. 16개의 조건 코드가 있으며, 하나의 조건 코드는 4 비트의 명령을 할당 받을 수 있습니다. 그 후 남는 2비트는 결과 레지스터로 사용하고, 2비트는 첫번째 인자 레지스터로 사용하고, 1비트는 상태값 플래그이며, 그 외에 비트는 실제 인자값 등으로 사용합니다. 중요한 것은, 비트를 명령어, 레지스터, 다른 필드 등으로 설정한 뒤에 오직 12비트만 값을 쓰기 위해 남는다는 점입니다. 12 비트이니 총 4096개의 다른 값을 가질 수 있습니다.\n이 말인 즉슨 ARM 명령은 제한적인 값만을 MOV를 통해 직접 사용할 수 있다는 점입니다. 만약 숫자를 직접 사용할 수 없다면, 파트로 나누어서 여러 작은 숫자를 사용해야 할 것입니다.\n하지만 여기에 더 나아가서 생각해 보면, 12비트를 단순 숫자로 사용하지 말고, 12비트를 8비트 숫자로 나눈 후 4비트 로테이션 필드(r)을 사용해서 오른쪽으로 로테이션을 해서 사용할 수도 있겠죠. 이걸 공식화 하면 이렇습니다: v = n ror 2*r. 이 공식을 사용한다면 실제 값은 오직 로테이션된 값(짝수)일 것입니다.\n아래에 이러한 값들에 대한 예제입니다.\nValid values: #256 // 1 ror 24 -- 256 #384 // 6 ror 26 -- 384 #484 // 121 ror 30 -- 484 #16384 // 1 ror 18 -- 16384 #2030043136 // 121 ror 8 -- 2030043136 #0x06000000 // 6 ror 8 -- 100663296 (0x06000000 in hex)  Invalid values: #370 // 185 ror 31 -- 31 is not in range (0 – 30) #511 // 1 1111 1111 -- bit-pattern can’t fit into one byte #0x06010000 // 1 1000 0001.. -- bit-pattern can’t fit into one byte 위의 예제를 볼 때, 전체 32bit 주소를 한번에 사용하는 것은 불가능은 아니라는 결론에 도달합니다. 우리는 아래 두 가지 옵션 중 한 가지 옵션을 충족 한다면 표현의 제한을 우회할 수 있습니다.\n 큰 값을 작은 파트를 통해 표현할 수 있음  MOV r0, #511 사용 대신 511을 두개의 파트로 나눠서 사용: MOV r0, #256과 ADD r0, #255   ldr r1,=value를 사용해서 값을 불러올 수 있는 경우. 그러니까 MOV나 PC-연관 불러오기가 불가능하지 않은 경우입니다.  LDR r1, =511    만약 불가능한 숫자를 어셈블러를 통해 불러오려고 한다면 Error: Invalid Constant 라는 문구와 함께 에러가 발생할 것입니다. 만약 이 에러가 발생한다면, 어떤 뜻인지 알고 뭘 해야하는지 알겠죠. 만약에 #511을 R0에 불러오고 싶다고 생각해 봅시다.\n.section .text .global _start  _start: \tmov r0, #511  bkpt 만약 이 코드를 어셈블리어로 변경하면, 어셈블러는 에러를 출력할 것입니다.\nazeria@labs:~$ as test.s -o test.o test.s: Assembler messages: test.s:5: Error: invalid constant (1ff) after fixup 이러한 에러가 날 경우 511을 여러 파트로 쪼개서 사용하거나, LDR을 위에서 설명한 것 처럼 사용하면 됩니다.\n.section .text .global _start  _start:  mov r0, #256 /* 1 ror 24 = 256, so it's valid */  add r0, #255 /* 255 ror 0 = 255, valid. r0 = 256 + 255 = 511 */  ldr r1, =511 /* load 511 from the literal pool using LDR */  bkpt 만약 특정 숫자가 사용 가능한 값인지 확인하기 위해서는 직접 계산할 필요 없이 저자가 작성한 rotater.py를 사용해서 확인할 수 있습니다.\nazeria@labs:~$ python rotator.py Enter the value you want to check: 511  Sorry, 511 cannot be used as an immediate number and has to be split.  azeria@labs:~$ python rotator.py Enter the value you want to check: 256  The number 256 can be used as a valid immediate number. 1 ror 24 -- 256 ","wordCount":"2317","inLanguage":"en","datePublished":"2021-09-19T16:52:34+09:00","dateModified":"2021-09-19T16:52:34+09:00","author":{"@type":"Person","name":"deguru22"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://deguru22.github.io/2021/09/19/arm-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-4-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0-%EB%B0%8F-%EC%A0%80%EC%9E%A5/"},"publisher":{"@type":"Organization","name":"데구루루x2 놀이터","logo":{"@type":"ImageObject","url":"https://deguru22.github.io/ico/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://deguru22.github.io/ accesskey=h title="데구루루x2 놀이터 (Alt + H)"><img src=/images/deguru22.jpg alt=logo aria-label=logo height=35>데구루루x2 놀이터</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://deguru22.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://deguru22.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://deguru22.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://deguru22.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://deguru22.github.io/posts/>Posts</a></div><h1 class=post-title>ARM 어셈블리 튜토리얼 (4) 메모리 명령어: 불러오기 및 저장</h1><div class=post-description>ARM 어셈블리 기본 내용</div><div class=post-meta>September 19, 2021&nbsp;·&nbsp;11 min&nbsp;·&nbsp;deguru22&nbsp;|&nbsp;<a href=https://github.com/deguru22/deguru22.github.io/content/posts/arm-assembly-4.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ec%b2%ab-%eb%b2%88%ec%a7%b8-%eb%8b%a8%ec%88%9c%ed%95%9c-%ec%98%88%ec%a0%9c aria-label="첫 번째 단순한 예제">첫 번째 단순한 예제</a></li><li><a href=#1-%ec%98%a4%ed%94%84%ec%85%8b-%ed%8f%bc-%ea%b0%92%ec%9d%84-%ec%a7%81%ec%a0%91-%ec%98%a4%ed%94%84%ec%85%8b%ec%9c%bc%eb%a1%9c-%ec%82%ac%ec%9a%a9 aria-label="1. 오프셋 폼: 값을 직접 오프셋으로 사용">1. 오프셋 폼: 값을 직접 오프셋으로 사용</a></li><li><a href=#2-%ec%98%a4%ed%94%84%ec%85%8b-%ed%8f%bc-%eb%a0%88%ec%a7%80%ec%8a%a4%ed%84%b0%eb%a5%bc-%ec%98%a4%ed%94%84%ec%85%8b%ec%9c%bc%eb%a1%9c-%ec%82%ac%ec%9a%a9 aria-label="2. 오프셋 폼: 레지스터를 오프셋으로 사용">2. 오프셋 폼: 레지스터를 오프셋으로 사용</a></li><li><a href=#3-%ec%98%a4%ed%94%84%ec%85%8b-%ed%8f%bc-%ec%8a%a4%ec%bc%80%ec%9d%bc%eb%90%9c-%eb%a0%88%ec%a7%80%ec%8a%a4%ed%84%b0%eb%a5%bc-%ec%98%a4%ed%94%84%ec%85%8b%ec%9c%bc%eb%a1%9c-%ec%82%ac%ec%9a%a9 aria-label="3. 오프셋 폼: 스케일된 레지스터를 오프셋으로 사용">3. 오프셋 폼: 스케일된 레지스터를 오프셋으로 사용</a></li><li><a href=#%ec%a0%95%eb%a6%ac aria-label=정리>정리</a></li><li><a href=#pc-%ea%b8%b0%eb%b0%98-%ec%a3%bc%ec%86%8c%ec%9d%98-ldr aria-label="PC 기반 주소의 LDR">PC 기반 주소의 LDR</a></li><li><a href=#arm%ec%97%90%ec%84%9c%ec%9d%98-%ea%b0%92immediate-values-%ec%82%ac%ec%9a%a9 aria-label="ARM에서의 값(Immediate Values) 사용">ARM에서의 값(Immediate Values) 사용</a></li></ul></div></details></div><div class=post-content><p>ARM Assembly에 대해 공부하던 중 좋은 글이 있어 번역 하였다.</p><p>출처: Azeria Labs (<a href=https://azeria-labs.com/writing-arm-assembly-part-4/>https://azeria-labs.com/writing-arm-assembly-part-4/</a>)</p><hr><p>ARM은 메모리 접근 시 오직 불러오기-저장(load-store, LDR and STR) 명령만을 사용 하도록 하는 불러오기-저장 모델을 사용합니다. <strong>x86에서 대부분의 명령들은 직접 메모리 안의 데이터를 접근하는 것과 달리, ARM에서는 데이터는 반드시 처리 전에 레지스터로 불러오는 과정을 거쳐야 합니다.</strong> 이 말인 즉슨 특정 메모리에 올라와 있는 32-bit 값을 ARM에서 증가 시키려면 3개의 명령어(불러오기, 증가하기, 저장)를 실행 해야 한다는 이야기 입니다.</p><p>ARM에서의 불러오기와 저장 명령의 기본을 설명하기 전에, 기본적인 예제들과 세가지 오프셋 폼, 그리고 각각의 오프셋 폼 별 존재하는 세가지 주소 모드를 배울겁니다. 각각의 예제에서는 같은 어셈블리 명령어에 다른 LDR/STR 오프셋 폼을 사용하여 단순하게 할것입니다. 이 튜토리얼을 잘 이해하기 위해서는 GDB에서 직접 실행해 보면 좋습니다.</p><p>&lt;정리></p><ol><li>오프셋 폼: 직접 입력한 값을 오프셋으로<ul><li>주소 모드: 오프셋</li><li>주소 모드: Pre-Indexed</li><li>주소 모드: Post-Indexed</li></ul></li><li>오프셋 폼: 레지스터를 오프셋으로<ul><li>주소 모드: 오프셋</li><li>주소 모드: Pre-Indexed</li><li>주소 모드: Post-Indexed</li></ul></li><li>오프셋 폼: 스케일된 레지스터를 오프셋으로<ul><li>주소 모드: 오프셋</li><li>주소 모드: Pre-Indexed</li><li>주소 모드: Post-Indexed</li></ul></li></ol><h2 id=첫-번째-단순한-예제>첫 번째 단순한 예제<a hidden class=anchor aria-hidden=true href=#첫-번째-단순한-예제>#</a></h2><p>일반적으로 LDR은 메모리에서 레지스터로 값을 불러올 때 사용하며, STR은 레지스터의 값을 특정 메모리 주소에 저장할 때 사용합니다.</p><p><img loading=lazy src=https://user-images.githubusercontent.com/42140558/133919635-c3adc921-430a-4457-a211-c96fff93788a.png alt="메모리 &amp;lt;-&amp;gt; 레지스터"></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#a6e22e>LDR</span> <span style=color:#a6e22e>R2</span>, [<span style=color:#a6e22e>R0</span>]   <span style=color:#960050;background-color:#1e0010>@</span> [<span style=color:#a6e22e>R0</span>] <span style=color:#f92672>-</span> <span style=color:#a6e22e>R0의</span> <span style=color:#a6e22e>값이</span> <span style=color:#a6e22e>메모리</span> <span style=color:#a6e22e>주소</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>STR</span> <span style=color:#a6e22e>R2</span>, [<span style=color:#a6e22e>R1</span>]   <span style=color:#960050;background-color:#1e0010>@</span> [<span style=color:#a6e22e>R1</span>] <span style=color:#f92672>-</span> <span style=color:#a6e22e>R1의</span> <span style=color:#a6e22e>값이</span> <span style=color:#a6e22e>메모리</span> <span style=color:#a6e22e>주소</span>
</span></span></code></pre></div><ul><li>LDR 명령어: R0가 갖고있는 메모리 주소에 위치하고 있는 값을 R2에 저장</li><li>STR 명령어: R2가 갖고있는 값을 메모리에 저장</li></ul><p>어셈블리 프로그램으로 작성한 프로그램은 아래와 같습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span>.<span style=color:#a6e22e>data</span>          <span style=color:#75715e>/* .data section 은 자동으로 생기며 위치를 알기 매우 쉬움 */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>var1</span><span style=color:#f92672>:</span> .<span style=color:#a6e22e>word</span> <span style=color:#ae81ff>3</span>  <span style=color:#75715e>/* 메모리 안에 있는 variable 1 */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>var2</span><span style=color:#f92672>:</span> .<span style=color:#a6e22e>word</span> <span style=color:#ae81ff>4</span>  <span style=color:#75715e>/* 메모리 안에 있는 variable 2 */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>text</span>          <span style=color:#75715e>/* 코드 섹션 시작점 */</span> 
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>global</span> <span style=color:#a6e22e>_start</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>_start</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ldr</span> <span style=color:#a6e22e>r0</span>, <span style=color:#a6e22e>adr_var1</span>  <span style=color:#960050;background-color:#1e0010>@</span> <span style=color:#a6e22e>var1</span> <span style=color:#a6e22e>메모리</span> <span style=color:#a6e22e>주소를</span> <span style=color:#a6e22e>label</span> <span style=color:#a6e22e>adr_var1</span> <span style=color:#a6e22e>통해</span> <span style=color:#a6e22e>R0에</span> <span style=color:#a6e22e>저장</span> 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ldr</span> <span style=color:#a6e22e>r1</span>, <span style=color:#a6e22e>adr_var2</span>  <span style=color:#960050;background-color:#1e0010>@</span> <span style=color:#a6e22e>var2</span> <span style=color:#a6e22e>메모리</span> <span style=color:#a6e22e>주소를</span> <span style=color:#a6e22e>label</span> <span style=color:#a6e22e>adr_var2</span> <span style=color:#a6e22e>통해</span> <span style=color:#a6e22e>R1에</span> <span style=color:#a6e22e>저장</span> 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ldr</span> <span style=color:#a6e22e>r2</span>, [<span style=color:#a6e22e>r0</span>]      <span style=color:#960050;background-color:#1e0010>@</span> <span style=color:#a6e22e>R0에서</span> <span style=color:#a6e22e>가져온</span> <span style=color:#a6e22e>값</span>(<span style=color:#ae81ff>0x03</span>)<span style=color:#a6e22e>을</span> <span style=color:#a6e22e>R2</span> <span style=color:#a6e22e>위치에</span> <span style=color:#a6e22e>저장</span>  
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>str</span> <span style=color:#a6e22e>r2</span>, [<span style=color:#a6e22e>r1</span>]      <span style=color:#960050;background-color:#1e0010>@</span> <span style=color:#a6e22e>R2에서</span> <span style=color:#a6e22e>가져온</span> <span style=color:#a6e22e>값</span>(<span style=color:#ae81ff>0x03</span>)<span style=color:#a6e22e>을</span> <span style=color:#a6e22e>R1</span> <span style=color:#a6e22e>위치에</span> <span style=color:#a6e22e>저장</span> 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>bkpt</span>             
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>adr_var1</span><span style=color:#f92672>:</span> .<span style=color:#a6e22e>word</span> <span style=color:#a6e22e>var1</span>  <span style=color:#75715e>/* var1 주소 저장 */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>adr_var2</span><span style=color:#f92672>:</span> .<span style=color:#a6e22e>word</span> <span style=color:#a6e22e>var2</span>  <span style=color:#75715e>/* var2 주소 저장 */</span>
</span></span></code></pre></div><p>위 코드의 아래쪽에 우리의 리터럴 풀(Literal Pool, 코드 섹션과 동일한 메모리 공간으로 상수, 문자열, 오프셋 등을 포지션과 관계없이 저장 및 사용하기 위해 사용)이 있는데, data 섹션에 있는 var1과 var2의 메모리 주소를 저장하기 위해 사용했습니다. var1, var2의 값이 저장된 주소를 adr_var1, adr_var2로 저장했습니다. 첫번째 LDR은 var1의 주소를 레지스터 R0에 저장합니다. 두번째 LDR은 var2의 주소를 레지스터 R1에 저장합니다. 그 후 R0에 저장된 메모리 주소를 통해 해당 메모리에 저장되어 있는 값을 R2에 불러옵니다. R2에 불러온 값은 R1에 저장되어있는 메모리 주소에 기록합니다.</p><p>우리가 레지스터에 뭔가를 불러올 때, 중괄호([ ])의 의미는 우리가 뭔가를 불러오기 위한 메모리 주소를 뜻합니다.</p><p>우리가 뭔가를 메모리 주소에 저장할 때, 중괄호([ ])의 의미는 우리가 뭔가를 저장할 때 사용할 메모리 주소를 뜻합니다.</p><p>이러한 내용들이 실제 내용보다 복잡해 보이니까, 텍스트가 아닌 구체적인 사례를 보면서 어떻게 메모리에서 값을 불러오고 저장하는지 알아봅시다.</p><p><img loading=lazy src=https://user-images.githubusercontent.com/42140558/133919649-51411fc0-7d8c-475a-9c5d-5ee1e1f72934.png alt=레지스터></p><p>같은 코드를 디버거에서 보면 아래와 같습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#a6e22e>gef</span><span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>disassemble</span> <span style=color:#a6e22e>_start</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Dump</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>assembler</span> <span style=color:#a6e22e>code</span> <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>_start</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span> <span style=color:#ae81ff>0x00008074</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>0</span><span style=color:#f92672>&gt;:</span>      <span style=color:#a6e22e>ldr</span>  <span style=color:#a6e22e>r0</span>, [<span style=color:#a6e22e>pc</span>, <span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>12</span>]   ; <span style=color:#ae81ff>0x8088</span> &lt;<span style=color:#f92672>adr_var1</span>&gt;
</span></span><span style=display:flex><span> <span style=color:#ae81ff>0x00008078</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>4</span><span style=color:#f92672>&gt;:</span>      <span style=color:#a6e22e>ldr</span>  <span style=color:#a6e22e>r1</span>, [<span style=color:#a6e22e>pc</span>, <span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>12</span>]   ; <span style=color:#ae81ff>0x808c</span> &lt;<span style=color:#f92672>adr_var2</span>&gt;
</span></span><span style=display:flex><span> <span style=color:#ae81ff>0x0000807c</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>8</span><span style=color:#f92672>&gt;:</span>      <span style=color:#a6e22e>ldr</span>  <span style=color:#a6e22e>r2</span>, [<span style=color:#a6e22e>r0</span>]
</span></span><span style=display:flex><span> <span style=color:#ae81ff>0x00008080</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>12</span><span style=color:#f92672>&gt;:</span>     <span style=color:#a6e22e>str</span>  <span style=color:#a6e22e>r2</span>, [<span style=color:#a6e22e>r1</span>]
</span></span><span style=display:flex><span> <span style=color:#ae81ff>0x00008084</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>16</span><span style=color:#f92672>&gt;:</span>     <span style=color:#a6e22e>bx</span>   <span style=color:#a6e22e>lr</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>End</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>assembler</span> <span style=color:#a6e22e>dump</span>.
</span></span></code></pre></div><p>위 두 개의 LDR 명령을 보면, 레이블들이 [pc, #12]로 바뀌었습니다. 이러한 형태를 PC-관련 주소(PC-Relative addressing)라고 합니다. 우리가 레이블을 사용했기때문에 컴파일러가 리터럴 풀에서 값을 특정할 수 있습니다(PC+12). 이 값을 직접 계산할 수도 있고, 아니면 레이블을 사용할 수도 있습니다. 두 개의 유일한 차이점은, 당신이 수동으로 포지션을 계산 하느냐 마느냐 입니다. PC-관련 주소에 대한 자세한 내용은 이 챕터의 아래쪽에서 다루도록 하겠습니다.</p><p>추가 노트: 만약 왜 effective PC가 현재의 PC에서 왜 2개의 명령어를 앞서 있는지를 까먹었다면, Part 2를 복습하세요. 복습하기 귀찮다면&mldr; PC는 현재 주소에서 더하기 8(ARM 기준) 혹은 4(Thumb 기준)해서 저장되기 때문입니다.</p><p><img loading=lazy src=https://user-images.githubusercontent.com/42140558/133919656-57d7e7eb-ab53-4133-b644-53e1e822338d.png alt=어셈블리></p><h2 id=1-오프셋-폼-값을-직접-오프셋으로-사용>1. 오프셋 폼: 값을 직접 오프셋으로 사용<a hidden class=anchor aria-hidden=true href=#1-오프셋-폼-값을-직접-오프셋으로-사용>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#a6e22e>STR</span> <span style=color:#a6e22e>Ra</span>, [<span style=color:#a6e22e>Rb</span>, <span style=color:#a6e22e>imm</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>LDR</span> <span style=color:#a6e22e>Ra</span>, [<span style=color:#a6e22e>Rc</span>, <span style=color:#a6e22e>imm</span>]
</span></span></code></pre></div><p>위의 예제는 값(숫자)을 직접 오프셋으로 사용하는 경우입니다. 해당 값을 베이스 레지스터에서 더하거나 뺀 후 메모리 접근 시 사용합니다. 오프셋 값은 컴파일 시 결정됩니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span>.<span style=color:#a6e22e>data</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>var1</span><span style=color:#f92672>:</span> .<span style=color:#a6e22e>word</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>var2</span><span style=color:#f92672>:</span> .<span style=color:#a6e22e>word</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>text</span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>global</span> <span style=color:#a6e22e>_start</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>_start</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ldr</span> <span style=color:#a6e22e>r0</span>, <span style=color:#a6e22e>adr_var1</span>  <span style=color:#960050;background-color:#1e0010>@</span> <span style=color:#a6e22e>var1의</span> <span style=color:#a6e22e>메모리</span> <span style=color:#a6e22e>주소를</span> <span style=color:#a6e22e>adr_var1에서</span> <span style=color:#a6e22e>가져와서</span> <span style=color:#a6e22e>R0에</span> <span style=color:#a6e22e>저장</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ldr</span> <span style=color:#a6e22e>r1</span>, <span style=color:#a6e22e>adr_var2</span>  <span style=color:#960050;background-color:#1e0010>@</span> <span style=color:#a6e22e>var2의</span> <span style=color:#a6e22e>메모리</span> <span style=color:#a6e22e>주소를</span> <span style=color:#a6e22e>adr_var2에서</span> <span style=color:#a6e22e>가져와서</span> <span style=color:#a6e22e>R1에</span> <span style=color:#a6e22e>저장</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ldr</span> <span style=color:#a6e22e>r2</span>, [<span style=color:#a6e22e>r0</span>]      <span style=color:#960050;background-color:#1e0010>@</span> <span style=color:#a6e22e>R0에</span> <span style=color:#a6e22e>저장된</span> <span style=color:#a6e22e>메모리</span> <span style=color:#a6e22e>주소</span> <span style=color:#a6e22e>저장돼</span> <span style=color:#a6e22e>있는</span> <span style=color:#a6e22e>값</span>(<span style=color:#ae81ff>0x03</span>)<span style=color:#a6e22e>을</span> <span style=color:#a6e22e>R2에</span> <span style=color:#a6e22e>저장</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>str</span> <span style=color:#a6e22e>r2</span>, [<span style=color:#a6e22e>r1</span>, <span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>2</span>]  <span style=color:#960050;background-color:#1e0010>@</span> <span style=color:#a6e22e>주소</span> <span style=color:#a6e22e>모드</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>R2에</span> <span style=color:#a6e22e>저장된</span> <span style=color:#a6e22e>값</span>(<span style=color:#ae81ff>0x03</span>)<span style=color:#a6e22e>을</span> <span style=color:#a6e22e>R1에</span> <span style=color:#a6e22e>저장된</span> <span style=color:#a6e22e>메모리</span> <span style=color:#a6e22e>값</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span> <span style=color:#a6e22e>위치에</span> <span style=color:#a6e22e>저장함</span>. <span style=color:#a6e22e>베이스</span> <span style=color:#a6e22e>레지스터</span>(<span style=color:#a6e22e>R1</span>) <span style=color:#a6e22e>값에는</span> <span style=color:#a6e22e>변동</span> <span style=color:#a6e22e>없음</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>str</span> <span style=color:#a6e22e>r2</span>, [<span style=color:#a6e22e>r1</span>, <span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>4</span>]<span style=color:#f92672>!</span> <span style=color:#960050;background-color:#1e0010>@</span> <span style=color:#a6e22e>주소</span> <span style=color:#a6e22e>모드</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>pre</span><span style=color:#f92672>-</span><span style=color:#a6e22e>indexed</span>. <span style=color:#a6e22e>R2에</span> <span style=color:#a6e22e>저장된</span> <span style=color:#a6e22e>값</span>(<span style=color:#ae81ff>0x03</span>)<span style=color:#a6e22e>을</span> <span style=color:#a6e22e>R1에</span> <span style=color:#a6e22e>저장된</span> <span style=color:#a6e22e>메모리</span> <span style=color:#a6e22e>값</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span><span style=color:#a6e22e>에</span> <span style=color:#a6e22e>저장함</span>. <span style=color:#a6e22e>베이스</span> <span style=color:#a6e22e>레지스터</span>(<span style=color:#a6e22e>R1</span>) <span style=color:#a6e22e>변동</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>R1</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>R1</span><span style=color:#f92672>+</span><span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ldr</span> <span style=color:#a6e22e>r3</span>, [<span style=color:#a6e22e>r1</span>], <span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>4</span>  <span style=color:#960050;background-color:#1e0010>@</span> <span style=color:#a6e22e>주소</span> <span style=color:#a6e22e>모드</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>post</span><span style=color:#f92672>-</span><span style=color:#a6e22e>indexed</span>. <span style=color:#a6e22e>R1에</span> <span style=color:#a6e22e>저장된</span> <span style=color:#a6e22e>메모리</span> <span style=color:#a6e22e>주소</span> <span style=color:#a6e22e>내의</span> <span style=color:#a6e22e>값을</span> <span style=color:#a6e22e>R3에</span> <span style=color:#a6e22e>저장함</span>. <span style=color:#a6e22e>베이스</span> <span style=color:#a6e22e>레지스터</span>(<span style=color:#a6e22e>R1</span>) <span style=color:#a6e22e>변경됨</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>R1</span><span style=color:#f92672>=</span><span style=color:#a6e22e>R1</span><span style=color:#f92672>+</span><span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>bkpt</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>adr_var1</span><span style=color:#f92672>:</span> .<span style=color:#a6e22e>word</span> <span style=color:#a6e22e>var1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>adr_var2</span><span style=color:#f92672>:</span> .<span style=color:#a6e22e>word</span> <span style=color:#a6e22e>var2</span>
</span></span></code></pre></div><p>위 프로그램을 <code>ldr.s</code>로 저장하고 컴파일 후 GDB에서 실행하면 어떻게 되는지 봅시다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#a6e22e>$</span> <span style=color:#a6e22e>as</span> <span style=color:#a6e22e>ldr</span>.<span style=color:#a6e22e>s</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>o</span> <span style=color:#a6e22e>ldr</span>.<span style=color:#a6e22e>o</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>$</span> <span style=color:#a6e22e>ld</span> <span style=color:#a6e22e>ldr</span>.<span style=color:#a6e22e>o</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>o</span> <span style=color:#a6e22e>ldr</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>$</span> <span style=color:#a6e22e>gdb</span> <span style=color:#a6e22e>ldr</span>
</span></span></code></pre></div><p>GDB(gef 설치된 버전)에서 _start에 breakpoint를 걸고 프로그램을 실행해 봅시다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#a6e22e>gef</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>break</span> <span style=color:#a6e22e>_start</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>gef</span><span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>run</span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#a6e22e>gef</span><span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>nexti</span> <span style=color:#ae81ff>3</span> <span style=color:#75715e>/* 다음 3개 명령 실행 */</span>
</span></span></code></pre></div><p>레지스터들이 아래 값으로 채워진 것을 확인할 수 있습니다(값은 시스템 별로 상이할 수 있으니 참고하세요).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#a6e22e>$r0</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0x00010098</span> <span style=color:#f92672>-&gt;</span> <span style=color:#ae81ff>0x00000003</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>$r1</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0x0001009c</span> <span style=color:#f92672>-&gt;</span> <span style=color:#ae81ff>0x00000004</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>$r2</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0x00000003</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>$r3</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0x00000000</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>$r4</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0x00000000</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>$r5</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0x00000000</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>$r6</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0x00000000</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>$r7</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0x00000000</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>$r8</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0x00000000</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>$r9</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0x00000000</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>$r10</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0x00000000</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>$r11</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0x00000000</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>$r12</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0x00000000</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>$sp</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0xbefff7e0</span> <span style=color:#f92672>-&gt;</span> <span style=color:#ae81ff>0x00000001</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>$lr</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0x00000000</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>$pc</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0x00010080</span> <span style=color:#f92672>-&gt;</span> &lt;<span style=color:#f92672>_start</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#a6e22e>12</span>&gt; <span style=color:#a6e22e>str</span> <span style=color:#a6e22e>r2</span>, [<span style=color:#a6e22e>r1</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>$cpsr</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0x00000010</span>
</span></span></code></pre></div><p>다음에 실행될 명령어는 오프셋 주소 모드의 STR 명령입니다. 이 명령은 R2의 값(0x3)을 R1이 저장하고 있는 메모리 주소(0x1009c) + 오프셋(#2) = 0x1009e 위치에 저장할 것입니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#a6e22e>gef</span><span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>nexti</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>gef</span><span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>x</span><span style=color:#f92672>/</span><span style=color:#a6e22e>w</span> <span style=color:#ae81ff>0x1009e</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0x1009e</span> &lt;<span style=color:#f92672>var2</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#a6e22e>2</span>&gt;<span style=color:#f92672>:</span> <span style=color:#ae81ff>0x3</span>
</span></span></code></pre></div><p>다음 STR 명령은 pre-indexed 주소 모드를 사용합니다. 이 모드 적용 여부는 느낌표(!)를 통해 알 수 있습니다. 이 모드의 다른점은 베이스 레지스터가 R2의 값이 저장될 최종 메모리 주소로 업데이트 된다는 점입니다. 이 말인 즉슨, 우리는 R2에 저장된 값(0x3)을 R1이 가지고 있는 메모리 주소(0x1009c) + 오프셋(#4) = 0x100A0에 저장하고, R1을 이 주소(0x100A0)로 업데이트 한다는 것이죠.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#a6e22e>gef</span><span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>nexti</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>gef</span><span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>x</span><span style=color:#f92672>/</span><span style=color:#a6e22e>w</span> <span style=color:#f92672>**</span><span style=color:#ae81ff>0x100A0</span><span style=color:#f92672>**</span>
</span></span><span style=display:flex><span><span style=color:#f92672>**</span><span style=color:#ae81ff>0x100a0</span><span style=color:#f92672>**:</span> <span style=color:#ae81ff>0x3</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>gef</span><span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>info</span> <span style=color:#a6e22e>register</span> <span style=color:#a6e22e>r1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>r1</span> <span style=color:#f92672>**</span><span style=color:#ae81ff>0x100a0</span><span style=color:#f92672>**</span> <span style=color:#ae81ff>65696</span> 
</span></span></code></pre></div><p>마지막 LDR 명령은 post-indexed 주소 모드를 사용합니다. 이 모드는 베이스 레지스터(R1)을 최종 주소로 사용하고, 오프셋을 계산(R1+4) 후 해당 값을 업데이트 합니다. 이 말인 즉슨, R1+4가 아니라 R1(0x100A0)에 저장된 값을 찾아서 R3에 불러옵니다. 그 후 R1을 R1(0x100A0) + 오프셋(#4) = 0x100A4 로 업데이트 합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#a6e22e>gef</span><span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>info</span> <span style=color:#a6e22e>register</span> <span style=color:#a6e22e>r1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>r1</span> <span style=color:#f92672>**</span><span style=color:#ae81ff>0x100a4</span><span style=color:#f92672>**</span> <span style=color:#ae81ff>65700</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>gef</span><span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>info</span> <span style=color:#a6e22e>register</span> <span style=color:#a6e22e>r3</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>r3</span> <span style=color:#f92672>**</span><span style=color:#ae81ff>0x3</span><span style=color:#f92672>**</span> <span style=color:#ae81ff>3</span>
</span></span></code></pre></div><p>아래에 위 과정을 그림으로 표현해 보았습니다.</p><p><img loading=lazy src=https://user-images.githubusercontent.com/42140558/133919665-0a8a1d57-6b69-46bb-b1e5-fdc44c248fe2.png alt=레지스터></p><h2 id=2-오프셋-폼-레지스터를-오프셋으로-사용>2. 오프셋 폼: 레지스터를 오프셋으로 사용<a hidden class=anchor aria-hidden=true href=#2-오프셋-폼-레지스터를-오프셋으로-사용>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#a6e22e>STR</span> <span style=color:#a6e22e>Ra</span>, [<span style=color:#a6e22e>Rb</span>, <span style=color:#f92672>**</span><span style=color:#a6e22e>Rc</span><span style=color:#f92672>**</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>LDR</span> <span style=color:#a6e22e>Ra</span>, [<span style=color:#a6e22e>Rb</span>, <span style=color:#f92672>**</span><span style=color:#a6e22e>Rc</span><span style=color:#f92672>**</span>]
</span></span></code></pre></div><p>이 오프셋 폼은 레지스터를 오프셋으로 사용합니다. 이러한 오프셋 폼은 코드 내에서 런타임에 인덱스를 계산해서 배열을 접근할 때 사용합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span>.<span style=color:#a6e22e>data</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>var1</span><span style=color:#f92672>:</span> .<span style=color:#a6e22e>word</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>var2</span><span style=color:#f92672>:</span> .<span style=color:#a6e22e>word</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>text</span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>global</span> <span style=color:#a6e22e>_start</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>_start</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ldr</span> <span style=color:#a6e22e>r0</span>, <span style=color:#a6e22e>adr_var1</span>  <span style=color:#960050;background-color:#1e0010>@</span> <span style=color:#a6e22e>adr_var1에</span> <span style=color:#a6e22e>저장된</span> <span style=color:#a6e22e>var1의</span> <span style=color:#a6e22e>메모리</span> <span style=color:#a6e22e>주소를</span> <span style=color:#a6e22e>R0에</span> <span style=color:#a6e22e>저장</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ldr</span> <span style=color:#a6e22e>r1</span>, <span style=color:#a6e22e>adr_var2</span>  <span style=color:#960050;background-color:#1e0010>@</span> <span style=color:#a6e22e>adr_var2에</span> <span style=color:#a6e22e>저장된</span> <span style=color:#a6e22e>var2의</span> <span style=color:#a6e22e>메모리</span> <span style=color:#a6e22e>주소를</span> <span style=color:#a6e22e>R1에</span> <span style=color:#a6e22e>저장</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ldr</span> <span style=color:#a6e22e>r2</span>, [<span style=color:#a6e22e>r0</span>]      <span style=color:#960050;background-color:#1e0010>@</span> <span style=color:#a6e22e>R0에</span> <span style=color:#a6e22e>저장된</span> <span style=color:#a6e22e>메모리</span> <span style=color:#a6e22e>주소에서</span> <span style=color:#a6e22e>가져온</span> <span style=color:#a6e22e>값</span>(<span style=color:#ae81ff>0x03</span>)<span style=color:#a6e22e>을</span> <span style=color:#a6e22e>Offset</span> <span style=color:#a6e22e>R2에</span> <span style=color:#a6e22e>저장</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>str</span> <span style=color:#a6e22e>r2</span>, [<span style=color:#a6e22e>r1</span>, <span style=color:#a6e22e>r2</span>]  <span style=color:#960050;background-color:#1e0010>@</span> <span style=color:#a6e22e>주소</span> <span style=color:#a6e22e>모드</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>오프셋</span>. <span style=color:#a6e22e>R2에</span> <span style=color:#a6e22e>저장된</span> <span style=color:#a6e22e>값</span>(<span style=color:#ae81ff>0x03</span>)<span style=color:#a6e22e>을</span> <span style=color:#a6e22e>R1에</span> <span style=color:#a6e22e>저장된</span> <span style=color:#a6e22e>메모리</span> <span style=color:#a6e22e>주소에</span> <span style=color:#a6e22e>오프셋</span> <span style=color:#a6e22e>R2</span>(<span style=color:#ae81ff>0x03</span>)<span style=color:#a6e22e>을</span> <span style=color:#a6e22e>포함하여</span> <span style=color:#a6e22e>저장</span>. <span style=color:#a6e22e>베이스</span> <span style=color:#a6e22e>레지스터</span> <span style=color:#a6e22e>변동</span> <span style=color:#a6e22e>없음</span>.
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>str</span> <span style=color:#a6e22e>r2</span>, [<span style=color:#a6e22e>r1</span>, <span style=color:#a6e22e>r2</span>]<span style=color:#f92672>!</span> <span style=color:#960050;background-color:#1e0010>@</span> <span style=color:#a6e22e>주소</span> <span style=color:#a6e22e>모드</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>pre</span><span style=color:#f92672>-</span><span style=color:#a6e22e>indexed</span>. <span style=color:#a6e22e>R2에</span> <span style=color:#a6e22e>저장된</span> <span style=color:#a6e22e>값</span>(<span style=color:#ae81ff>0x03</span>)<span style=color:#a6e22e>을</span> <span style=color:#a6e22e>R1에</span> <span style=color:#a6e22e>저장된</span> <span style=color:#a6e22e>메모리</span> <span style=color:#a6e22e>주소에</span> <span style=color:#a6e22e>오프셋</span> <span style=color:#a6e22e>R2</span>(<span style=color:#ae81ff>0x03</span>)<span style=color:#a6e22e>을</span> <span style=color:#a6e22e>포함하여</span> <span style=color:#a6e22e>저장</span>. <span style=color:#a6e22e>베이스</span> <span style=color:#a6e22e>레지스터</span> <span style=color:#a6e22e>변경</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>R1</span><span style=color:#f92672>=</span><span style=color:#a6e22e>R1</span><span style=color:#f92672>+</span><span style=color:#a6e22e>R2</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ldr</span> <span style=color:#a6e22e>r3</span>, [<span style=color:#a6e22e>r1</span>], <span style=color:#a6e22e>r2</span>  <span style=color:#960050;background-color:#1e0010>@</span> <span style=color:#a6e22e>주소</span> <span style=color:#a6e22e>모드</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>post</span><span style=color:#f92672>-</span><span style=color:#a6e22e>indexed</span>. <span style=color:#a6e22e>R1에</span> <span style=color:#a6e22e>저장된</span> <span style=color:#a6e22e>메모리</span> <span style=color:#a6e22e>주소에</span> <span style=color:#a6e22e>존재하는</span> <span style=color:#a6e22e>값을</span> <span style=color:#a6e22e>R3에</span> <span style=color:#a6e22e>불러옴</span>. <span style=color:#a6e22e>베이스</span> <span style=color:#a6e22e>레지스터</span> <span style=color:#a6e22e>변동</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>R1</span><span style=color:#f92672>=</span><span style=color:#a6e22e>R1</span><span style=color:#f92672>+</span><span style=color:#a6e22e>R2</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>bx</span> <span style=color:#a6e22e>lr</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>adr_var1</span><span style=color:#f92672>:</span> .<span style=color:#a6e22e>word</span> <span style=color:#a6e22e>var1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>adr_var2</span><span style=color:#f92672>:</span> .<span style=color:#a6e22e>word</span> <span style=color:#a6e22e>var2</span>
</span></span></code></pre></div><p>오프셋 주소 모드로 첫번째 STR 명령을 실행 하면, R2의 값 (0x3)이 메모리 주소(0x1009c + 0x3 = 0x1009F)에 저장됨</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#a6e22e>gef</span><span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>x</span><span style=color:#f92672>/</span><span style=color:#a6e22e>w</span> <span style=color:#ae81ff>0x0001009F</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0x1009f</span> &lt;<span style=color:#f92672>var2</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#a6e22e>3</span>&gt;<span style=color:#f92672>:</span> <span style=color:#ae81ff>0x00000003</span>
</span></span></code></pre></div><p>두 번째 STR 명령은 pre-indexed 주소 모드로 위와 같은 결과를 가지지만, 차이점은 베이스 레지스터(R1)을 계산한 메모리 값(R1+R2)으로 변경 하는 점이 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#a6e22e>gef</span><span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>info</span> <span style=color:#a6e22e>register</span> <span style=color:#a6e22e>r1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>r1</span> <span style=color:#f92672>**</span><span style=color:#ae81ff>0x1009f</span><span style=color:#f92672>**</span> <span style=color:#ae81ff>65695</span>
</span></span></code></pre></div><p>마지막 LDR 명령은 post-indexed 주소 모드로 R1에서 찾은 메모리 주소의 값을 R2로 불러온 후에 베이스 레지스터 R1을 업데이트(R1+R2 = 0x1009f + 0x3 = 0x100a2) 합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#a6e22e>gef</span><span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>info</span> <span style=color:#a6e22e>register</span> <span style=color:#a6e22e>r1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>r1</span> <span style=color:#ae81ff>0x100a2</span> <span style=color:#ae81ff>65698</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>gef</span><span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>info</span> <span style=color:#a6e22e>register</span> <span style=color:#a6e22e>r3</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>r3</span> <span style=color:#ae81ff>0x3</span> <span style=color:#ae81ff>3</span>
</span></span></code></pre></div><p><img loading=lazy src=https://user-images.githubusercontent.com/42140558/133919675-135e82a5-1066-4a2f-a7e4-ea2e8f18844c.png alt=레지스터></p><h2 id=3-오프셋-폼-스케일된-레지스터를-오프셋으로-사용>3. 오프셋 폼: 스케일된 레지스터를 오프셋으로 사용<a hidden class=anchor aria-hidden=true href=#3-오프셋-폼-스케일된-레지스터를-오프셋으로-사용>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#a6e22e>LDR</span> <span style=color:#a6e22e>Ra</span>, [<span style=color:#a6e22e>Rb</span>, <span style=color:#f92672>**</span><span style=color:#a6e22e>Rc</span>, &lt;<span style=color:#f92672>shifter</span>&gt;<span style=color:#f92672>**</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>STR</span> <span style=color:#a6e22e>Ra</span>, [<span style=color:#a6e22e>Rb</span>, <span style=color:#f92672>**</span><span style=color:#a6e22e>Rc</span>, &lt;<span style=color:#f92672>shifter</span>&gt;<span style=color:#f92672>**</span>]
</span></span></code></pre></div><p>세 번째 오프셋 폼은 스케일된 레지스터를 오프셋으로 가집니다. 위의 폼에서 Rb는 베이스 레지스터이고 Rc는 직접 값 오프셋(혹은 값을 가진 레지스터)을 기반으로 오른쪽/왼쪽 쉬프팅된() 값입니다. 이 말인 즉슨, 배럴 쉬프터가 오프셋 스케일링에 사용됐다는 이야기 입니다. 이 오프셋을 사용하는 예는 배열 값을 순차적으로 접근할 때 입니다. 아래에 GDB를 통해 실행하는 예제를 참고해 주세요.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span>.<span style=color:#a6e22e>data</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>var1</span><span style=color:#f92672>:</span> .<span style=color:#a6e22e>word</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>var2</span><span style=color:#f92672>:</span> .<span style=color:#a6e22e>word</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>text</span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>global</span> <span style=color:#a6e22e>_start</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>_start</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ldr</span> <span style=color:#a6e22e>r0</span>, <span style=color:#a6e22e>adr_var1</span>         
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ldr</span> <span style=color:#a6e22e>r1</span>, <span style=color:#a6e22e>adr_var2</span>         
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ldr</span> <span style=color:#a6e22e>r2</span>, [<span style=color:#a6e22e>r0</span>]             
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>str</span> <span style=color:#a6e22e>r2</span>, [<span style=color:#a6e22e>r1</span>, <span style=color:#a6e22e>r2</span>, <span style=color:#a6e22e>LSL</span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>2</span>]  
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>str</span> <span style=color:#a6e22e>r2</span>, [<span style=color:#a6e22e>r1</span>, <span style=color:#a6e22e>r2</span>, <span style=color:#a6e22e>LSL</span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>2</span>]<span style=color:#f92672>!</span> 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ldr</span> <span style=color:#a6e22e>r3</span>, [<span style=color:#a6e22e>r1</span>], <span style=color:#a6e22e>r2</span>, <span style=color:#a6e22e>LSL</span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>2</span>  
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>bkpt</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>adr_var1</span><span style=color:#f92672>:</span> .<span style=color:#a6e22e>word</span> <span style=color:#a6e22e>var1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>adr_var2</span><span style=color:#f92672>:</span> .<span style=color:#a6e22e>word</span> <span style=color:#a6e22e>var2</span>
</span></span></code></pre></div><p>첫번째 STR 명령은 오프셋 주소 모드를 사용하여 R2 내의 값을 특정 메모리 주소([r1, r2, LSL#2] 연산 결과)에 기록합니다. 메모리 주소를 계산해 보면, R1의 값을 베이스로 사용(이 경우에는 R1에 var2의 주소값이 들어 있음)하고, R2의 값(0x3)을 가져와서 왼쪽으로 2번 쉬프팅을 합니다. 아래 그림을 통해 어떻게 메모리 주소가 계산되는지 보겠습니다.</p><p><img loading=lazy src=https://user-images.githubusercontent.com/42140558/133919679-4a0f38bd-4d0f-4934-96e4-eff8f75f2af1.png alt="메모리 주소 계산"></p><p>두번째 STR 명령은 pre-indexed 주소 모드를 사용합니다. 이 말은, 이전 명령과 동일한 명령을 수행하지만, 다른점은 R1을 계산한 메모리 주소 값으로 변경하는 점입니다. 다른 말로 얘기하자면, 메모리 주소(R1(0x1009c) + 왼쪽 오프셋으로 #2만큼 옮겨진(0x03 LSL#2 = 0xC) = 0x100a8)에 값을 저장한 후 R1을 0x100a8로 업데이트 합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#a6e22e>gef</span><span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>info</span> <span style=color:#a6e22e>register</span> <span style=color:#a6e22e>r1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>r1</span> <span style=color:#f92672>**</span><span style=color:#ae81ff>0x100a8</span><span style=color:#f92672>**</span> <span style=color:#ae81ff>65704</span>
</span></span></code></pre></div><p>마지막 LDR 명령은 post-indexed 주소 모드를 사용합니다. 이 말은, R1(0x100a8)에 저장된 메모리 주소 내의 값을 R3에 저장한 후 베이스 레지스터인 R1을 계산한 값(R1(0x100a8) + R2 오프셋(0x3)을 왼쪽으로 #2 만큼 쉬프팅한 값 (0xC)=0x100b4) 으로 변경합니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#a6e22e>gef</span><span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>info</span> <span style=color:#a6e22e>register</span> <span style=color:#a6e22e>r1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>r1</span> <span style=color:#f92672>**</span><span style=color:#ae81ff>0x100b4</span><span style=color:#f92672>**</span> <span style=color:#ae81ff>65716</span>
</span></span></code></pre></div><h2 id=정리>정리<a hidden class=anchor aria-hidden=true href=#정리>#</a></h2><p>LDR/STR에는 세가지의 오프셋 모드가 있습니다.</p><ol><li>직접 값을 오프셋으로 사용하는 경우<ul><li>ldr r3, [r1, #4]</li></ul></li><li>레지스터를 오프셋으로 사용하는 경우<ul><li>ldr r3, [r1, r2]</li></ul></li><li>스케일된 레지스터를 오프셋으로 사용하는 경우<ul><li>ldr r3, [r1, r2, LSL#2]</li></ul></li></ol><p>LDR/STR의 다양한 모드를 기억하는 방법은 아래와 같습니다.</p><ol><li>만약 **!**가 있다면 <strong>prefix 주소 모드</strong><ul><li>ldr r3, [r1, #4]!</li><li>ldr r3, [r1, r2]!</li><li>ldr r3, [r1, r2, LSL#2]!</li></ul></li><li>만약 **베이스 레지스터가 <input disabled type=checkbox> **로 감싸져 있다면, <strong>postfix 주소 모드</strong><ul><li>ldr r3, [r1], #r</li><li>ldr r3, [r1], r2</li><li>ldr r3, [r1], r2, LSL#2</li></ul></li><li><strong>다른거</strong>는 <strong>오프셋 주소 모드</strong><ul><li>ldr r3, [r1, #4]</li><li>ldr r3, [r1, r2]</li><li>ldr r3, [r1, r2, LSL#2]</li></ul></li></ol><h2 id=pc-기반-주소의-ldr>PC 기반 주소의 LDR<a hidden class=anchor aria-hidden=true href=#pc-기반-주소의-ldr>#</a></h2><p>LDR은 단순히 메모리의 값을 레지스터로 옮기는데만 사용되지 않습니다. 가끔 아래와 같은 문법을 볼 수 있는데요&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span>.<span style=color:#a6e22e>section</span> .<span style=color:#a6e22e>text</span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>global</span> <span style=color:#a6e22e>_start</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>_start</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>ldr</span> <span style=color:#a6e22e>r0</span>, <span style=color:#f92672>=</span><span style=color:#a6e22e>jump</span>        <span style=color:#75715e>/* load the address of the function label jump into R0 */</span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>ldr</span> <span style=color:#a6e22e>r1</span>, <span style=color:#f92672>=</span><span style=color:#ae81ff>0x68DB00AD</span>  <span style=color:#75715e>/* load the value 0x68DB00AD into R1 */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>jump</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>ldr</span> <span style=color:#a6e22e>r2</span>, <span style=color:#f92672>=</span><span style=color:#ae81ff>511</span>         <span style=color:#75715e>/* load the value 511 into R2 */</span> 
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>bkpt</span>
</span></span></code></pre></div><p>이러한 명령어들은 &ldquo;의사 명령어(pseudo-instructions)&rdquo; 라고 부릅니다. 우리는 이 명령어 문법을 리터럴 풀에 있는 데이터를 참조하기 위해 사용합니다. 리터럴 풀은 같은 섹션에 있는 메모리 공간(왜냐하면 리터럴 풀은 코드의 일부이기 때문입니다)으로, 상수나 문자열, 오프셋 등을 저장하기 위해 사용합니다. 위의 예제에서는 의사 명령어를 사용해서 함수의 오프셋을 참조하기 위해 사용하고, 하나의 명령을 통해 32-bit 상수를 레지스터로 옮기는데에 사용됩니다. 왜냐하면 ARM은 8-bit 값만 한번에 불러올 수 있기 때문입니다. 뭐라고요?! 왜 그런지를 이해하기 위해서는, 어떻게 ARM이 값(Immediate Values)을 핸들링 하는지 알아야 합니다.</p><h2 id=arm에서의-값immediate-values-사용>ARM에서의 값(Immediate Values) 사용<a hidden class=anchor aria-hidden=true href=#arm에서의-값immediate-values-사용>#</a></h2><p>ARM 에서 레지스터에 값을 로드하는 것은 x86처럼 직관적이지 않습니다. 값을 사용할 때 제약사항이 있습니다. 어떠한 제약사항이 있으며 어떻게 해결 해야하는지가 ARM 어셈블리의 가장 재밌는 부분이며, 이러한 제약 사항을 어떻게 해결해야 하는지에 대한 팁들을 아래에 기술해 두었습니다(힌트: LDR).</p><p>우리는 각각의 ARM 명령어가 32-bit인걸 알고 있으며, 모든 명령어는 조건기반입니다. 16개의 조건 코드가 있으며, 하나의 조건 코드는 4 비트의 명령을 할당 받을 수 있습니다. 그 후 남는 2비트는 결과 레지스터로 사용하고, 2비트는 첫번째 인자 레지스터로 사용하고, 1비트는 상태값 플래그이며, 그 외에 비트는 실제 인자값 등으로 사용합니다. 중요한 것은, 비트를 명령어, 레지스터, 다른 필드 등으로 설정한 뒤에 오직 12비트만 값을 쓰기 위해 남는다는 점입니다. 12 비트이니 총 4096개의 다른 값을 가질 수 있습니다.</p><p>이 말인 즉슨 ARM 명령은 제한적인 값만을 MOV를 통해 직접 사용할 수 있다는 점입니다. 만약 숫자를 직접 사용할 수 없다면, 파트로 나누어서 여러 작은 숫자를 사용해야 할 것입니다.</p><p>하지만 여기에 더 나아가서 생각해 보면, 12비트를 단순 숫자로 사용하지 말고, 12비트를 8비트 숫자로 나눈 후 4비트 로테이션 필드(r)을 사용해서 오른쪽으로 로테이션을 해서 사용할 수도 있겠죠. 이걸 공식화 하면 이렇습니다: <code>v = n ror 2*r</code>. 이 공식을 사용한다면 실제 값은 오직 로테이션된 값(짝수)일 것입니다.</p><p>아래에 이러한 값들에 대한 예제입니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#a6e22e>Valid</span> <span style=color:#a6e22e>values</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>256</span>        <span style=color:#75715e>// 1 ror 24 --&gt; 256
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>384</span>        <span style=color:#75715e>// 6 ror 26 --&gt; 384
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>484</span>        <span style=color:#75715e>// 121 ror 30 --&gt; 484
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>16384</span>      <span style=color:#75715e>// 1 ror 18 --&gt; 16384
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>2030043136</span> <span style=color:#75715e>// 121 ror 8 --&gt; 2030043136
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>0x06000000</span> <span style=color:#75715e>// 6 ror 8 --&gt; 100663296 (0x06000000 in hex)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Invalid</span> <span style=color:#a6e22e>values</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>370</span>        <span style=color:#75715e>// 185 ror 31 --&gt; 31 is not in range (0 – 30)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>511</span>        <span style=color:#75715e>// 1 1111 1111 --&gt; bit-pattern can’t fit into one byte
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>0x06010000</span> <span style=color:#75715e>// 1 1000 0001.. --&gt; bit-pattern can’t fit into one byte
</span></span></span></code></pre></div><p>위의 예제를 볼 때, 전체 32bit 주소를 한번에 사용하는 것은 불가능은 아니라는 결론에 도달합니다. 우리는 아래 두 가지 옵션 중 한 가지 옵션을 충족 한다면 표현의 제한을 우회할 수 있습니다.</p><ol><li>큰 값을 작은 파트를 통해 표현할 수 있음<ol><li>MOV r0, #511 사용 대신</li><li>511을 두개의 파트로 나눠서 사용: MOV r0, #256과 ADD r0, #255</li></ol></li><li><code>ldr r1,=value</code>를 사용해서 값을 불러올 수 있는 경우. 그러니까 MOV나 PC-연관 불러오기가 불가능하지 않은 경우입니다.<ol><li>LDR r1, =511</li></ol></li></ol><p>만약 불가능한 숫자를 어셈블러를 통해 불러오려고 한다면 <code>Error: Invalid Constant</code> 라는 문구와 함께 에러가 발생할 것입니다. 만약 이 에러가 발생한다면, 어떤 뜻인지 알고 뭘 해야하는지 알겠죠. 만약에 #511을 R0에 불러오고 싶다고 생각해 봅시다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span>.<span style=color:#a6e22e>section</span> .<span style=color:#a6e22e>text</span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>global</span> <span style=color:#a6e22e>_start</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>_start</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mov</span>    <span style=color:#a6e22e>r0</span>, <span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>511</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>bkpt</span>
</span></span></code></pre></div><p>만약 이 코드를 어셈블리어로 변경하면, 어셈블러는 에러를 출력할 것입니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#a6e22e>azeria</span><span style=color:#960050;background-color:#1e0010>@</span><span style=color:#a6e22e>labs</span><span style=color:#f92672>:~</span><span style=color:#a6e22e>$</span> <span style=color:#a6e22e>as</span> <span style=color:#a6e22e>test</span>.<span style=color:#a6e22e>s</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>o</span> <span style=color:#a6e22e>test</span>.<span style=color:#a6e22e>o</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>test</span>.<span style=color:#a6e22e>s</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>Assembler</span> <span style=color:#a6e22e>messages</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>test</span>.<span style=color:#a6e22e>s</span><span style=color:#f92672>:</span><span style=color:#ae81ff>5</span><span style=color:#f92672>:</span> Error<span style=color:#f92672>:</span> <span style=color:#a6e22e>invalid</span> <span style=color:#a6e22e>constant</span> (<span style=color:#ae81ff>1</span><span style=color:#a6e22e>ff</span>) <span style=color:#a6e22e>after</span> <span style=color:#a6e22e>fixup</span>
</span></span></code></pre></div><p>이러한 에러가 날 경우 511을 여러 파트로 쪼개서 사용하거나, LDR을 위에서 설명한 것 처럼 사용하면 됩니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span>.<span style=color:#a6e22e>section</span> .<span style=color:#a6e22e>text</span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>global</span> <span style=color:#a6e22e>_start</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>_start</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>mov</span> <span style=color:#a6e22e>r0</span>, <span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>256</span>   <span style=color:#75715e>/* 1 ror 24 = 256, so it&#39;s valid */</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>add</span> <span style=color:#a6e22e>r0</span>, <span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>255</span>   <span style=color:#75715e>/* 255 ror 0 = 255, valid. r0 = 256 + 255 = 511 */</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>ldr</span> <span style=color:#a6e22e>r1</span>, <span style=color:#f92672>=</span><span style=color:#ae81ff>511</span>   <span style=color:#75715e>/* load 511 from the literal pool using LDR */</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>bkpt</span>
</span></span></code></pre></div><p>만약 특정 숫자가 사용 가능한 값인지 확인하기 위해서는 직접 계산할 필요 없이 저자가 작성한 <a href=https://raw.githubusercontent.com/azeria-labs/rotator/master/rotator.py>rotater.py</a>를 사용해서 확인할 수 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#a6e22e>azeria</span><span style=color:#960050;background-color:#1e0010>@</span><span style=color:#a6e22e>labs</span><span style=color:#f92672>:~</span><span style=color:#a6e22e>$</span> <span style=color:#a6e22e>python</span> <span style=color:#a6e22e>rotator</span>.<span style=color:#a6e22e>py</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Enter</span> <span style=color:#a6e22e>the</span> <span style=color:#a6e22e>value</span> <span style=color:#a6e22e>you</span> <span style=color:#a6e22e>want</span> <span style=color:#a6e22e>to</span> <span style=color:#a6e22e>check</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>511</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Sorry</span>, <span style=color:#ae81ff>511</span> <span style=color:#a6e22e>cannot</span> <span style=color:#a6e22e>be</span> <span style=color:#a6e22e>used</span> <span style=color:#a6e22e>as</span> <span style=color:#a6e22e>an</span> <span style=color:#a6e22e>immediate</span> <span style=color:#a6e22e>number</span> <span style=color:#a6e22e>and</span> <span style=color:#a6e22e>has</span> <span style=color:#a6e22e>to</span> <span style=color:#a6e22e>be</span> <span style=color:#a6e22e>split</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>azeria</span><span style=color:#960050;background-color:#1e0010>@</span><span style=color:#a6e22e>labs</span><span style=color:#f92672>:~</span><span style=color:#a6e22e>$</span> <span style=color:#a6e22e>python</span> <span style=color:#a6e22e>rotator</span>.<span style=color:#a6e22e>py</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Enter</span> <span style=color:#a6e22e>the</span> <span style=color:#a6e22e>value</span> <span style=color:#a6e22e>you</span> <span style=color:#a6e22e>want</span> <span style=color:#a6e22e>to</span> <span style=color:#a6e22e>check</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>256</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>The</span> <span style=color:#a6e22e>number</span> <span style=color:#ae81ff>256</span> <span style=color:#a6e22e>can</span> <span style=color:#a6e22e>be</span> <span style=color:#a6e22e>used</span> <span style=color:#a6e22e>as</span> <span style=color:#a6e22e>a</span> <span style=color:#a6e22e>valid</span> <span style=color:#a6e22e>immediate</span> <span style=color:#a6e22e>number</span>.
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span> <span style=color:#a6e22e>ror</span> <span style=color:#ae81ff>24</span> <span style=color:#f92672>--&gt;</span> <span style=color:#ae81ff>256</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://deguru22.github.io/tags/arm/>ARM</a></li><li><a href=https://deguru22.github.io/tags/assembly/>Assembly</a></li><li><a href=https://deguru22.github.io/tags/tutorial/>Tutorial</a></li></ul><nav class=paginav><a class=prev href=https://deguru22.github.io/2021/09/22/uri-scheme%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-%EA%B3%B5%EA%B2%A9-aws-workspace-rce-macos-finder-rce/><span class=title>« Prev Page</span><br><span>URI Scheme을 활용한 공격 - AWS Workspace RCE, macOS Finder RCE</span></a>
<a class=next href=https://deguru22.github.io/2021/09/05/%EC%BB%A8%ED%94%8C%EB%A3%A8%EC%96%B8%EC%8A%A4-ognl-injection-rce-%EC%B7%A8%EC%95%BD%EC%A0%90-cve-2021-26084/><span class=title>Next Page »</span><br><span>컨플루언스 OGNL Injection (RCE) 취약점 (CVE-2021-26084)</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share ARM 어셈블리 튜토리얼 (4) 메모리 명령어: 불러오기 및 저장 on twitter" href="https://twitter.com/intent/tweet/?text=ARM%20%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%20%ed%8a%9c%ed%86%a0%eb%a6%ac%ec%96%bc%20%284%29%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%eb%aa%85%eb%a0%b9%ec%96%b4%3a%20%eb%b6%88%eb%9f%ac%ec%98%a4%ea%b8%b0%20%eb%b0%8f%20%ec%a0%80%ec%9e%a5&url=https%3a%2f%2fdeguru22.github.io%2f2021%2f09%2f19%2farm-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25ED%258A%259C%25ED%2586%25A0%25EB%25A6%25AC%25EC%2596%25BC-4-%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC-%25EB%25AA%2585%25EB%25A0%25B9%25EC%2596%25B4-%25EB%25B6%2588%25EB%259F%25AC%25EC%2598%25A4%25EA%25B8%25B0-%25EB%25B0%258F-%25EC%25A0%2580%25EC%259E%25A5%2f&hashtags=ARM%2cAssembly%2cTutorial"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ARM 어셈블리 튜토리얼 (4) 메모리 명령어: 불러오기 및 저장 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdeguru22.github.io%2f2021%2f09%2f19%2farm-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25ED%258A%259C%25ED%2586%25A0%25EB%25A6%25AC%25EC%2596%25BC-4-%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC-%25EB%25AA%2585%25EB%25A0%25B9%25EC%2596%25B4-%25EB%25B6%2588%25EB%259F%25AC%25EC%2598%25A4%25EA%25B8%25B0-%25EB%25B0%258F-%25EC%25A0%2580%25EC%259E%25A5%2f&title=ARM%20%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%20%ed%8a%9c%ed%86%a0%eb%a6%ac%ec%96%bc%20%284%29%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%eb%aa%85%eb%a0%b9%ec%96%b4%3a%20%eb%b6%88%eb%9f%ac%ec%98%a4%ea%b8%b0%20%eb%b0%8f%20%ec%a0%80%ec%9e%a5&summary=ARM%20%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%20%ed%8a%9c%ed%86%a0%eb%a6%ac%ec%96%bc%20%284%29%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%eb%aa%85%eb%a0%b9%ec%96%b4%3a%20%eb%b6%88%eb%9f%ac%ec%98%a4%ea%b8%b0%20%eb%b0%8f%20%ec%a0%80%ec%9e%a5&source=https%3a%2f%2fdeguru22.github.io%2f2021%2f09%2f19%2farm-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25ED%258A%259C%25ED%2586%25A0%25EB%25A6%25AC%25EC%2596%25BC-4-%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC-%25EB%25AA%2585%25EB%25A0%25B9%25EC%2596%25B4-%25EB%25B6%2588%25EB%259F%25AC%25EC%2598%25A4%25EA%25B8%25B0-%25EB%25B0%258F-%25EC%25A0%2580%25EC%259E%25A5%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ARM 어셈블리 튜토리얼 (4) 메모리 명령어: 불러오기 및 저장 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fdeguru22.github.io%2f2021%2f09%2f19%2farm-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25ED%258A%259C%25ED%2586%25A0%25EB%25A6%25AC%25EC%2596%25BC-4-%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC-%25EB%25AA%2585%25EB%25A0%25B9%25EC%2596%25B4-%25EB%25B6%2588%25EB%259F%25AC%25EC%2598%25A4%25EA%25B8%25B0-%25EB%25B0%258F-%25EC%25A0%2580%25EC%259E%25A5%2f&title=ARM%20%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%20%ed%8a%9c%ed%86%a0%eb%a6%ac%ec%96%bc%20%284%29%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%eb%aa%85%eb%a0%b9%ec%96%b4%3a%20%eb%b6%88%eb%9f%ac%ec%98%a4%ea%b8%b0%20%eb%b0%8f%20%ec%a0%80%ec%9e%a5"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ARM 어셈블리 튜토리얼 (4) 메모리 명령어: 불러오기 및 저장 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fdeguru22.github.io%2f2021%2f09%2f19%2farm-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25ED%258A%259C%25ED%2586%25A0%25EB%25A6%25AC%25EC%2596%25BC-4-%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC-%25EB%25AA%2585%25EB%25A0%25B9%25EC%2596%25B4-%25EB%25B6%2588%25EB%259F%25AC%25EC%2598%25A4%25EA%25B8%25B0-%25EB%25B0%258F-%25EC%25A0%2580%25EC%259E%25A5%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ARM 어셈블리 튜토리얼 (4) 메모리 명령어: 불러오기 및 저장 on whatsapp" href="https://api.whatsapp.com/send?text=ARM%20%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%20%ed%8a%9c%ed%86%a0%eb%a6%ac%ec%96%bc%20%284%29%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%eb%aa%85%eb%a0%b9%ec%96%b4%3a%20%eb%b6%88%eb%9f%ac%ec%98%a4%ea%b8%b0%20%eb%b0%8f%20%ec%a0%80%ec%9e%a5%20-%20https%3a%2f%2fdeguru22.github.io%2f2021%2f09%2f19%2farm-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25ED%258A%259C%25ED%2586%25A0%25EB%25A6%25AC%25EC%2596%25BC-4-%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC-%25EB%25AA%2585%25EB%25A0%25B9%25EC%2596%25B4-%25EB%25B6%2588%25EB%259F%25AC%25EC%2598%25A4%25EA%25B8%25B0-%25EB%25B0%258F-%25EC%25A0%2580%25EC%259E%25A5%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ARM 어셈블리 튜토리얼 (4) 메모리 명령어: 불러오기 및 저장 on telegram" href="https://telegram.me/share/url?text=ARM%20%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%20%ed%8a%9c%ed%86%a0%eb%a6%ac%ec%96%bc%20%284%29%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20%eb%aa%85%eb%a0%b9%ec%96%b4%3a%20%eb%b6%88%eb%9f%ac%ec%98%a4%ea%b8%b0%20%eb%b0%8f%20%ec%a0%80%ec%9e%a5&url=https%3a%2f%2fdeguru22.github.io%2f2021%2f09%2f19%2farm-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25ED%258A%259C%25ED%2586%25A0%25EB%25A6%25AC%25EC%2596%25BC-4-%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC-%25EB%25AA%2585%25EB%25A0%25B9%25EC%2596%25B4-%25EB%25B6%2588%25EB%259F%25AC%25EC%2598%25A4%25EA%25B8%25B0-%25EB%25B0%258F-%25EC%25A0%2580%25EC%259E%25A5%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=deguru22/deguru22.github.io issue-term=url label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=https://deguru22.github.io/>데구루루x2 놀이터</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>