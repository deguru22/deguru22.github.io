<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ARM 어셈블리 튜토리얼 (1) 기초 | 데구루루x2 놀이터</title><meta name=keywords content="ARM,Assembly,Tutorial"><meta name=description content="ARM 어셈블리 기본 내용"><meta name=author content="deguru22"><link rel=canonical href=https://deguru22.github.io/2021/08/18/arm-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-1-%EA%B8%B0%EC%B4%88/><link crossorigin=anonymous href=/assets/css/stylesheet.min.5e2b4101351c21e906f398ae96901791830f58d430f96f2659dab7eaef7b3cb7.css integrity="sha256-XitBATUcIekG85iulpAXkYMPWNQw+W8mWdq36u97PLc=" rel="preload stylesheet" as=style><link rel=preload href=/images/deguru22.jpg as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://deguru22.github.io/ico/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://deguru22.github.io/ico/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://deguru22.github.io/ico/favicon-32x32.png><link rel=apple-touch-icon href=https://deguru22.github.io/ico/apple-touch-icon.png><link rel=mask-icon href=https://deguru22.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.98.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-164568875-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="ARM 어셈블리 튜토리얼 (1) 기초"><meta property="og:description" content="ARM 어셈블리 기본 내용"><meta property="og:type" content="article"><meta property="og:url" content="https://deguru22.github.io/2021/08/18/arm-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-1-%EA%B8%B0%EC%B4%88/"><meta property="og:image" content="https://deguru22.github.io/static/deguru22.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-18T23:44:56+09:00"><meta property="article:modified_time" content="2021-08-18T23:44:56+09:00"><meta property="og:site_name" content="데구루루x2 놀이터"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://deguru22.github.io/static/deguru22.jpg"><meta name=twitter:title content="ARM 어셈블리 튜토리얼 (1) 기초"><meta name=twitter:description content="ARM 어셈블리 기본 내용"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://deguru22.github.io/posts/"},{"@type":"ListItem","position":2,"name":"ARM 어셈블리 튜토리얼 (1) 기초","item":"https://deguru22.github.io/2021/08/18/arm-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-1-%EA%B8%B0%EC%B4%88/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ARM 어셈블리 튜토리얼 (1) 기초","name":"ARM 어셈블리 튜토리얼 (1) 기초","description":"ARM 어셈블리 기본 내용","keywords":["ARM","Assembly","Tutorial"],"articleBody":"ARM Assembly에 대해 공부하던 중 좋은 글이 있어 번역 하였다.\n출처: Azeria Labs (https://azeria-labs.com/writing-arm-assembly-part-1/)\n ARM Assembly Basics 튜토리얼 시리즈에 오신 여러분을 환영합니다! 이 문서는 ARM Exploit 개발 튜토리얼 전에 알아야 할 내용을 담고 있습니다. ARM 쉘코드를 작성하고 ROP 체인을 만들기 전에 ARM Assembly 기초에 대해서 알아야 합니다.\n아래 주제들을 순차적으로 다룰 예정입니다.\nARM Assembly 기본 튜토리얼 시리즈:\n Part 1. ARM Assembly 기본 Part 2. 데이터 타입 레지스터 Part 3. ARM 명령어 셋 Part 4. 메모리 명령들: 데이터 불러오기 및 저장하기 Part 5. 다중 불러오기 및 저장하기 Part 6. 조건부 실행 및 분기문 Part 7. 스택과 함수  튜토리얼을 이해하기 위해서는 ARM 기반의 테스트 베드(Lab Environment)가 필요합니다. 라즈베리파이와같은 ARM 기반의 기기가 없다면, VM에 QEMU와 라즈베리파이 디스트로를 이용하여 테스트 환경을 구축할 수 있습니다. 또한 GDB가 익숙하지 않다면 다른 튜토리얼을 통해서 미리 공부해 주새요. 이 튜토리얼에서는 ARM 32-bit 환경에 집중할 것이고, 예제들은 모두 ARMv6 기반으로 컴파일 되었습니다.\n왜 ARM 인가? 이 튜토리얼은 ARM Assembly의 기본을 가르치기 위해 작성했습니다. 특히 ARM 플랫폼에서 익스플로잇을 작성하고 싶은 사람들에게 유용할 것입니다. 당신은 이미 당신 곁에 많은 ARM 프로세서들이 존재한다는 사실을 알고 있을 것입니다. 내 주변을 돌아보면, 인텔 프로세서보다 훨씬 더 많은 ARM 프로세서를 확인할 수 있습니다. 스마트폰, 라우터, 요즘 잘 팔리는 IoT 기기 등에서 말이죠. 이 말인 즉슨, ARM 프로세서는 전 세계에서 가장 널리 보급된 CPU 코어 중 하나라고 할 수 있다는 것입니다. PC나 IoT 기기들이 부적절한 입력값 검증으로 인한 버퍼 오버플로우 등의 공격에 영향을 받기 쉽다는 사실을 생각해 본다면, 널리 퍼진 ARM 기반의 기기들은 다양한 오용 가능성 혹은 공격의 타겟이 될 가능성이 있으며 그 가능성은 점점 높아질 것입니다.\n아직 x86 전문가가 ARM 전문가보다 많지만, ARM 어셈블리 언어는 널리 알려진 어셈블리 언어 중 가장 쉽습니다. 그런데 왜 사람들은 ARM에 관심을 가지지 않을까요? 아마도 인텔 프로세서보다 ARM 프로세서 관련한 참고 문헌 들이 적기 때문일 수 있습니다. x86 프로세서를 생각해 보면, Fuzzy Security나 Corelan Team에서 쓴 매우 훌륭한 튜토리얼들이 떠오릅니다. 이러한 튜토리얼을 기반으로 사람들이 실무적인 지식을 가지게 되고, 나아가 튜토리얼에서 커버하지 못한 내용들도 알아내게 됩니다. 만약 당신이 x86 익스플로잇에 관심이 많다면 위 튜토리얼을 통해 훌륭한 시작을 할 수 있을 것입니다. 이 튜토리얼 에서는 어셈블리 기본과 ARM에서 익스플로잇 작성 방법을 집중적으로 다룰 것입니다.\nARM 프로세서 vs 인텔 프로세서 인텔과 ARM에는 많은 다른점이 있지만, 가장 중요한 다른점은 명령어 셋(instruction set) 입니다. 인텔은 CISC(Complex Instruction Set Computing) 프로세서로서 크고 다양한 기능을 가진 명령어 셋을 가지고 있어서, 복잡한 명령어를 통해 메모리 접근을 하게 됩니다. 그러므로 ARM에 비해 다양한 명령어, 어드레싱 모드를 가지고 있지만 더 적은 레지스터를 가지고 있습니다. CISC 방식은 요즘의 PC, 워크스테이션, 서버 등에서 사용되고 있습니다.\nARM은 RISC(Reduced Instruction Set Computing) 프로세서로서 단순한, 100개 혹은 그보다 적은 명령어 셋을 가지고 있습니다.인텔과 다르게 ARM의 명령어는 단순하게 레지스터를 관리하고 메모리에 기록 혹은 메모리로부터 값을 불러오는 역할 정도만 수행합니다. 이말인 즉슨 메모리에 접근 할 때 Load/Store 명령만 사용할 수 있다는 얘깁니다. 좀 더 구체화 시켜보면, ARM에 올라와 있는 특정 메모리 주소 32-bit 내의 값을 증가 시키기 위해서는 오직 세 가지의 명령어 (불러오기, 증가, 그리고 저장) 만 필요하다는 이야기 입니다. 값을 처음 메모리에서 레지스터로 불러오고, 레지스터 안에서 증가시킨 뒤, 다시 레지스터에서 메모리로 저장시키면 됩니다.\nReduced Instruction Set은 장점과 단점이 있습니다. 장점 중 하나는 명령이 빠르게 실행될 수 있다는 것이며, 전체적으로 더 빠른 속도를 제공할 수 있다는 점입니다(RISC 시스템은 명령 실행 시간 단축을 위해 각 명령 당 clock cycle을 줄입니다). 반면에 단점은 적은 명령셋을 제공하기 때문에 소프트웨어를 만들 때 더욱 효율적으로 설계해야 한다는 점입니다. 그리고 ARM은 두 가지 모드가 있다는 점을 명심해야 합니다. ARM 모드와 Thumb 모드가 있습니다. Thumb 모드는 2바이트 혹은 4바이트가 될 수 있습니다(상세한 내용은 Part 3: ARM Instruction Set 참고).\n더 많은 ARM과 x86의 차이점은 아래와 같습니다.\n ARM은 대부분의 명령들을 조건부 분기 실행에 사용할 수 있습니다. 인텔 x86과 x86-64 시리즈는 리틀 인디언 포맷을 사용합니다. ARM 아키텍쳐는 버전3 이전에는 리틀 인디언 포맷을 사용했습니다. 그 이후로는 ARM 프로세서는 혼용 인디언(BI-Endian)을 지원하며 Endianness를 변경할 수 있는 기능을 탑재하고 있습니다.  이것들이 유일한 인텔과 ARM의 차이는 아니며, ARM 버전 별로의 차이들도 있습니다. 이 튜토리얼은 어떻게 ARM이 동작 하는지를 보여주기 위하여 작성된 것이기 때문에 최대한 일반적(generic)인 내용으로 작성 되었습니다. 기본을 이해하게 된다면, 그 이후로 각각 ARM 버전별 미묘한 차이를 쉽게 배울 수 있을 것입니다. 이 튜토리얼에서는 32-bit ARMv6 (라즈베리파이 1) 기반으로 작성 되었으므로, 설명들도 모두 해당 버전을 기반으로 작성되었습니다.\nARM 버전 별 이름이 헷갈릴 수 있습니다. 아래를 참고하세요:\nARM Family\n어셈블리 작성하기 ARM 익스플로잇 개발을 시작하기 전에, 어셈블리 프로그래밍의 기본을 이해해야 합니다. 그 전에, 왜 우리는 ARM 어셈블리가 “일반적인” 프로그래밍 / 스크립팅 언어가 아님에도 불구하고 필요할까요? 우리가 리버스 엔지니어링을 하고 ARM 바이너리의 플로우를 이해하고, 우리만의 ARM 쉘코드를 작성하고, ARM ROP 체인을 만들고, ARM 앱을 디버깅 할 일이 없다면 배울 필요가 없죠.\n리버스 엔지니어링과 익스플로잇 개발을 위해서 어셈블리 언어에 대해 속속들이 알 필요는 없지만 “빅 픽쳐\"는 이해하고 있어야 합니다. 이러한 기본기는 본 튜토리얼에서 다룰것입니다. 만약 더 깊게 알고싶다면 이 챕터 맨 아래의 링크들을 참고하세요.\n그렇다면, 어셈블리 언어란 정확하게 무엇일까요? 어셈블리 언어는 머신 코드의 상단에 있는 얇은 문법 레이어(thin syntax layer)로서, 컴퓨터가 알아듣는 바이너리 표현(머신 코드)을 인코딩 하여 보여주는 것입니다. 그러면 우리가 바로 기계 언어를 바로 쓰면 어떨까요? 음, 그렇다면 매우 고통스러울 것입니다. 우리 컴퓨터는 어셈블리 코드를 그대로 실행할 수 없습니다. 왜냐하면 기계어만 실행 가능하기 때문입니다. 우리는 어셈블리 코드를 기계어로 바꾸는 GNU 어셈블러인 GNU Binutils 프로젝트를 통해 *.s 확장자를 가진 소스코드를 처리할 것입니다.\n어셈블리를 *.s 확장자를 가진 파일로 작성 하였다면, 그것을 아래와 같이 as 명령어를 통해 변환 후 ld 명령을 통해 바이너리로 링크 시킬 수 있습니다.\n$ as program.s -o program.o # 어셈블리를 기계어로 $ ld program.o -o program # 기계어를 바이너리로 어셈블리의 내부에서 어셈블리 언어의 매우 아래에서부터 위까지 공부해봅시다. 매우 아래 레벨에는 우리는 기계 회로의 전기 신호가 있죠. 전류는 신호로 변환되어 두 개의 레벨로 나뉩니다 - 0 볼트를 “꺼짐”, 5 볼트를 “켜짐” 이라고 합시다. 왜냐하면 시각적으로는 회로가 정확하게 몇 볼트인지 알 수 없어서, 우리가 전류가 켜짐/꺼짐 상태임을 숫자 0과 1을 통해 나타내기 위함입니다. 그 후 0과 1을 컴퓨터 프로세서가 이해하는 가장 작은 단위인 기계어 형태로 표현합니다. 아래에 기계어로 작성한 명령어 예제입니다.\n1110 0001 1010 0000 0010 0000 0000 0001 여기까진 좋은데.. 저런 0과 1의 패턴이 어떤 뜻인지 기억하기 쉽지 않습니다. 그래서 우리는 니모닉(mnemonics)이라고 하는 0과 1의 바이너리 패턴을 이해하기 쉽도록 줄임말 형태를 사용하며, 이것이 각 기계어 명령어의 이름입니다. 이 프로그램은 어셈블리 언어 프로그램으로 불리며, 각 컴퓨터의 어셈블리 언어란 컴퓨터의 기계어를 니모닉의 집합으로 표현한 것을 말합니다. 그러므로, 어셈블리 언어는 인간이 컴퓨터를 프로그래밍 할 때 사용되는 가장 낮은 레벨의 언어입니다. 명령의 각 피연산자(operands)는 니모닉 다음에 옵니다. 아래의 예제를 참고해 주세요.\nMOV R2, R1 이제 우리는 어셈블리 프로그램이 니모닉 이라고 불리우는 언어적 정보의 집합으로 만들어 졌다는 것을 알았으며, 우리는 그것들을 기계어로 변환해야 한다는 사실을 알았습니다. 위에서 언급한 것 처럼 ARM 어셈블리의 경우에는 GNU Binutils 프로젝트에 포함되어 있는 as 명령어를 통해 기계어로 변환할 수 있으며, 이 과정을 어셈블링(assembling) 이라고 부릅니다.\n정리하면, 우리는 컴퓨터가 전기 신호의 존재 여부를 인식하도록 만들어 졌고, 우리는 다양한 신호의 집합을 0과 1(bits)의 집합으로 표현할 수 있다는 사실을 배웠습니다. 우리는 기계어(신호의 집합)를 사용해서 컴퓨터를 미리 설계된 방식으로 작동하도록 제어할 수 있습니다. 우리가 그러한 신호의 집합을 모두 외우고 있기 어려우므로, 줄임말인 니모닉(mnemonics)을 사용하여 각 작동 방식 별로 명령어(이름)를 부여했습니다. 니모닉의 집합을 컴퓨터의 어셈블리 언어라고 부르며 우리는 어셈블러 라고 불리는 프로그램을 사용해서 하이레벨 언어를 위해 컴파일러가 하는 것 처럼 니모닉의 집합을 컴퓨터가 이해할 수 있는 기계어로 변환합니다.\n더 자세히 알아보고 싶다면..  ARM 어셈블리의 회오리 투어(Whirlwind Tour)  https://www.coranac.com/tonc/text/asm.htm\n라즈베리파이의 ARM 어셈블러  http://thinkingeek.com/arm-assembler-raspberry-pi/\n 리버스 엔지니어링 실무: x86, x64, ARM, 윈도우즈 커널, 리버싱 도구, 난독화 (작성자: Bruce Dang, Alexandre Gazet, Elias Bachaalany and Sebastien Josse)\n  ARM 레퍼런스 메뉴얼\n  http://infocenter.arm.com/help/topic/com.arm.doc.dui0068b/index.html\n어셈블러 사용자 가이드  http://www.keil.com/support/man/docs/armasm/default.htm\n","wordCount":"1185","inLanguage":"en","datePublished":"2021-08-18T23:44:56+09:00","dateModified":"2021-08-18T23:44:56+09:00","author":{"@type":"Person","name":"deguru22"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://deguru22.github.io/2021/08/18/arm-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-1-%EA%B8%B0%EC%B4%88/"},"publisher":{"@type":"Organization","name":"데구루루x2 놀이터","logo":{"@type":"ImageObject","url":"https://deguru22.github.io/ico/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://deguru22.github.io/ accesskey=h title="데구루루x2 놀이터 (Alt + H)"><img src=/images/deguru22.jpg alt=logo aria-label=logo height=35>데구루루x2 놀이터</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://deguru22.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://deguru22.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://deguru22.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://deguru22.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://deguru22.github.io/posts/>Posts</a></div><h1 class=post-title>ARM 어셈블리 튜토리얼 (1) 기초</h1><div class=post-description>ARM 어셈블리 기본 내용</div><div class=post-meta>August 18, 2021&nbsp;·&nbsp;6 min&nbsp;·&nbsp;deguru22&nbsp;|&nbsp;<a href=https://github.com/deguru22/deguru22.github.io/content/posts/arm-assembly-1.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ec%99%9c-arm-%ec%9d%b8%ea%b0%80 aria-label="왜 ARM 인가?">왜 ARM 인가?</a></li><li><a href=#arm-%ed%94%84%eb%a1%9c%ec%84%b8%ec%84%9c-vs-%ec%9d%b8%ed%85%94-%ed%94%84%eb%a1%9c%ec%84%b8%ec%84%9c aria-label="ARM 프로세서 vs 인텔 프로세서">ARM 프로세서 vs 인텔 프로세서</a></li><li><a href=#%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac-%ec%9e%91%ec%84%b1%ed%95%98%ea%b8%b0 aria-label="어셈블리 작성하기">어셈블리 작성하기</a></li><li><a href=#%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%ec%9d%98-%eb%82%b4%eb%b6%80%ec%97%90%ec%84%9c aria-label="어셈블리의 내부에서">어셈블리의 내부에서</a></li><li><a href=#%eb%8d%94-%ec%9e%90%ec%84%b8%ed%9e%88-%ec%95%8c%ec%95%84%eb%b3%b4%ea%b3%a0-%ec%8b%b6%eb%8b%a4%eb%a9%b4 aria-label="더 자세히 알아보고 싶다면..">더 자세히 알아보고 싶다면..</a></li></ul></div></details></div><div class=post-content><p>ARM Assembly에 대해 공부하던 중 좋은 글이 있어 번역 하였다.</p><p>출처: Azeria Labs (<a href=https://azeria-labs.com/writing-arm-assembly-part-1/>https://azeria-labs.com/writing-arm-assembly-part-1/</a>)</p><hr><p>ARM Assembly Basics 튜토리얼 시리즈에 오신 여러분을 환영합니다! 이 문서는 ARM Exploit 개발 튜토리얼 전에 알아야 할 내용을 담고 있습니다. ARM 쉘코드를 작성하고 ROP 체인을 만들기 전에 ARM Assembly 기초에 대해서 알아야 합니다.</p><p>아래 주제들을 순차적으로 다룰 예정입니다.</p><p><strong>ARM Assembly 기본 튜토리얼 시리즈:</strong></p><ul><li>Part 1. ARM Assembly 기본</li><li>Part 2. 데이터 타입 레지스터</li><li>Part 3. ARM 명령어 셋</li><li>Part 4. 메모리 명령들: 데이터 불러오기 및 저장하기</li><li>Part 5. 다중 불러오기 및 저장하기</li><li>Part 6. 조건부 실행 및 분기문</li><li>Part 7. 스택과 함수</li></ul><p>튜토리얼을 이해하기 위해서는 ARM 기반의 테스트 베드(Lab Environment)가 필요합니다. 라즈베리파이와같은 ARM 기반의 기기가 없다면, <a href=https://azeria-labs.com/emulate-raspberry-pi-with-qemu/>VM에 QEMU와 라즈베리파이 디스트로를 이용하여 테스트 환경을 구축</a>할 수 있습니다. 또한 GDB가 익숙하지 않다면 <a href=https://azeria-labs.com/debugging-with-gdb-introduction/>다른 튜토리얼</a>을 통해서 미리 공부해 주새요. 이 튜토리얼에서는 ARM 32-bit 환경에 집중할 것이고, 예제들은 모두 ARMv6 기반으로 컴파일 되었습니다.</p><h2 id=왜-arm-인가>왜 ARM 인가?<a hidden class=anchor aria-hidden=true href=#왜-arm-인가>#</a></h2><p>이 튜토리얼은 ARM Assembly의 기본을 가르치기 위해 작성했습니다. 특히 ARM 플랫폼에서 익스플로잇을 작성하고 싶은 사람들에게 유용할 것입니다. 당신은 이미 당신 곁에 많은 ARM 프로세서들이 존재한다는 사실을 알고 있을 것입니다. 내 주변을 돌아보면, 인텔 프로세서보다 훨씬 더 많은 ARM 프로세서를 확인할 수 있습니다. 스마트폰, 라우터, 요즘 잘 팔리는 IoT 기기 등에서 말이죠. 이 말인 즉슨, ARM 프로세서는 전 세계에서 가장 널리 보급된 CPU 코어 중 하나라고 할 수 있다는 것입니다. PC나 IoT 기기들이 부적절한 입력값 검증으로 인한 버퍼 오버플로우 등의 공격에 영향을 받기 쉽다는 사실을 생각해 본다면, 널리 퍼진 ARM 기반의 기기들은 다양한 오용 가능성 혹은 공격의 타겟이 될 가능성이 있으며 그 가능성은 점점 높아질 것입니다.</p><p>아직 x86 전문가가 ARM 전문가보다 많지만, ARM 어셈블리 언어는 널리 알려진 어셈블리 언어 중 가장 쉽습니다. 그런데 왜 사람들은 ARM에 관심을 가지지 않을까요? 아마도 인텔 프로세서보다 ARM 프로세서 관련한 참고 문헌 들이 적기 때문일 수 있습니다. x86 프로세서를 생각해 보면, <a href=https://www.fuzzysecurity.com/tutorials/expDev/1.html>Fuzzy Security</a>나 <a href=https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-1-stack-based-overflows/>Corelan Team</a>에서 쓴 매우 훌륭한 튜토리얼들이 떠오릅니다. 이러한 튜토리얼을 기반으로 사람들이 실무적인 지식을 가지게 되고, 나아가 튜토리얼에서 커버하지 못한 내용들도 알아내게 됩니다. 만약 당신이 x86 익스플로잇에 관심이 많다면 위 튜토리얼을 통해 훌륭한 시작을 할 수 있을 것입니다. 이 튜토리얼 에서는 어셈블리 기본과 ARM에서 익스플로잇 작성 방법을 집중적으로 다룰 것입니다.</p><h2 id=arm-프로세서-vs-인텔-프로세서>ARM 프로세서 vs 인텔 프로세서<a hidden class=anchor aria-hidden=true href=#arm-프로세서-vs-인텔-프로세서>#</a></h2><p>인텔과 ARM에는 많은 다른점이 있지만, 가장 중요한 다른점은 명령어 셋(instruction set) 입니다. 인텔은 CISC(Complex Instruction Set Computing) 프로세서로서 크고 다양한 기능을 가진 명령어 셋을 가지고 있어서, 복잡한 명령어를 통해 메모리 접근을 하게 됩니다. 그러므로 ARM에 비해 다양한 명령어, 어드레싱 모드를 가지고 있지만 더 적은 레지스터를 가지고 있습니다. CISC 방식은 요즘의 PC, 워크스테이션, 서버 등에서 사용되고 있습니다.</p><p>ARM은 RISC(Reduced Instruction Set Computing) 프로세서로서 단순한, 100개 혹은 그보다 적은 명령어 셋을 가지고 있습니다.인텔과 다르게 ARM의 명령어는 단순하게 레지스터를 관리하고 메모리에 기록 혹은 메모리로부터 값을 불러오는 역할 정도만 수행합니다. 이말인 즉슨 메모리에 접근 할 때 Load/Store 명령만 사용할 수 있다는 얘깁니다. 좀 더 구체화 시켜보면, ARM에 올라와 있는 특정 메모리 주소 32-bit 내의 값을 증가 시키기 위해서는 오직 세 가지의 명령어 (불러오기, 증가, 그리고 저장) 만 필요하다는 이야기 입니다. 값을 처음 메모리에서 레지스터로 불러오고, 레지스터 안에서 증가시킨 뒤, 다시 레지스터에서 메모리로 저장시키면 됩니다.</p><p>Reduced Instruction Set은 장점과 단점이 있습니다. 장점 중 하나는 명령이 빠르게 실행될 수 있다는 것이며, 전체적으로 더 빠른 속도를 제공할 수 있다는 점입니다(RISC 시스템은 명령 실행 시간 단축을 위해 각 명령 당 clock cycle을 줄입니다). 반면에 단점은 적은 명령셋을 제공하기 때문에 소프트웨어를 만들 때 더욱 효율적으로 설계해야 한다는 점입니다. 그리고 ARM은 두 가지 모드가 있다는 점을 명심해야 합니다. ARM 모드와 Thumb 모드가 있습니다. Thumb 모드는 2바이트 혹은 4바이트가 될 수 있습니다(상세한 내용은 Part 3: ARM Instruction Set 참고).</p><p>더 많은 ARM과 x86의 차이점은 아래와 같습니다.</p><ul><li>ARM은 대부분의 명령들을 조건부 분기 실행에 사용할 수 있습니다.</li><li><strong>인텔 x86과 x86-64 시리즈는</strong> <strong>리틀 인디언</strong> 포맷을 사용합니다.</li><li>ARM 아키텍쳐는 버전3 이전에는 리틀 인디언 포맷을 사용했습니다. 그 이후로는 <strong>ARM 프로세서는 혼용 인디언(BI-Endian)을 지원하며 Endianness를 변경할 수 있는 기능을 탑재하고 있습니다.</strong></li></ul><p>이것들이 유일한 인텔과 ARM의 차이는 아니며, ARM 버전 별로의 차이들도 있습니다. 이 튜토리얼은 어떻게 ARM이 동작 하는지를 보여주기 위하여 작성된 것이기 때문에 최대한 일반적(generic)인 내용으로 작성 되었습니다. 기본을 이해하게 된다면, 그 이후로 각각 ARM 버전별 미묘한 차이를 쉽게 배울 수 있을 것입니다. 이 튜토리얼에서는 32-bit ARMv6 (라즈베리파이 1) 기반으로 작성 되었으므로, 설명들도 모두 해당 버전을 기반으로 작성되었습니다.</p><p>ARM 버전 별 이름이 헷갈릴 수 있습니다. 아래를 참고하세요:</p><p><a href=https://www.notion.so/89825ccddb7b4aa3adfd901bf54bb931>ARM Family</a></p><h2 id=어셈블리-작성하기>어셈블리 작성하기<a hidden class=anchor aria-hidden=true href=#어셈블리-작성하기>#</a></h2><p>ARM 익스플로잇 개발을 시작하기 전에, 어셈블리 프로그래밍의 기본을 이해해야 합니다. 그 전에, 왜 우리는 ARM 어셈블리가 &ldquo;일반적인&rdquo; 프로그래밍 / 스크립팅 언어가 아님에도 불구하고 필요할까요? 우리가 리버스 엔지니어링을 하고 ARM 바이너리의 플로우를 이해하고, 우리만의 ARM 쉘코드를 작성하고, ARM ROP 체인을 만들고, ARM 앱을 디버깅 할 일이 없다면 배울 필요가 없죠.</p><p>리버스 엔지니어링과 익스플로잇 개발을 위해서 어셈블리 언어에 대해 속속들이 알 필요는 없지만 &ldquo;빅 픽쳐"는 이해하고 있어야 합니다. 이러한 기본기는 본 튜토리얼에서 다룰것입니다. 만약 더 깊게 알고싶다면 이 챕터 맨 아래의 링크들을 참고하세요.</p><p>그렇다면, 어셈블리 언어란 정확하게 무엇일까요? 어셈블리 언어는 머신 코드의 상단에 있는 얇은 문법 레이어(thin syntax layer)로서, 컴퓨터가 알아듣는 바이너리 표현(머신 코드)을 인코딩 하여 보여주는 것입니다. 그러면 우리가 바로 기계 언어를 바로 쓰면 어떨까요? 음, 그렇다면 매우 고통스러울 것입니다. 우리 컴퓨터는 어셈블리 코드를 그대로 실행할 수 없습니다. 왜냐하면 기계어만 실행 가능하기 때문입니다. 우리는 어셈블리 코드를 기계어로 바꾸는 GNU 어셈블러인 GNU Binutils 프로젝트를 통해 *.s 확장자를 가진 소스코드를 처리할 것입니다.</p><p>어셈블리를 *.s 확장자를 가진 파일로 작성 하였다면, 그것을 아래와 같이 <code>as</code> 명령어를 통해 변환 후 <code>ld</code> 명령을 통해 바이너리로 링크 시킬 수 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#a6e22e>$</span> <span style=color:#a6e22e>as</span> <span style=color:#a6e22e>program</span>.<span style=color:#a6e22e>s</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>o</span> <span style=color:#a6e22e>program</span>.<span style=color:#a6e22e>o</span>  <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#a6e22e>어셈블리를</span> <span style=color:#a6e22e>기계어로</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>$</span> <span style=color:#a6e22e>ld</span> <span style=color:#a6e22e>program</span>.<span style=color:#a6e22e>o</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>o</span> <span style=color:#a6e22e>program</span>    <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#a6e22e>기계어를</span> <span style=color:#a6e22e>바이너리로</span>
</span></span></code></pre></div><h2 id=어셈블리의-내부에서>어셈블리의 내부에서<a hidden class=anchor aria-hidden=true href=#어셈블리의-내부에서>#</a></h2><p>어셈블리 언어의 매우 아래에서부터 위까지 공부해봅시다. 매우 아래 레벨에는 우리는 기계 회로의 전기 신호가 있죠. 전류는 신호로 변환되어 두 개의 레벨로 나뉩니다 - 0 볼트를 &ldquo;꺼짐&rdquo;, 5 볼트를 &ldquo;켜짐&rdquo; 이라고 합시다. 왜냐하면 시각적으로는 회로가 정확하게 몇 볼트인지 알 수 없어서, 우리가 전류가 켜짐/꺼짐 상태임을 숫자 0과 1을 통해 나타내기 위함입니다. 그 후 0과 1을 컴퓨터 프로세서가 이해하는 가장 작은 단위인 기계어 형태로 표현합니다. 아래에 기계어로 작성한 명령어 예제입니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#ae81ff>1110</span> <span style=color:#ae81ff>0001</span> <span style=color:#ae81ff>1010</span> <span style=color:#ae81ff>0000</span> <span style=color:#ae81ff>0010</span> <span style=color:#ae81ff>0000</span> <span style=color:#ae81ff>0000</span> <span style=color:#ae81ff>0001</span>
</span></span></code></pre></div><p>여기까진 좋은데.. 저런 0과 1의 패턴이 어떤 뜻인지 기억하기 쉽지 않습니다. 그래서 우리는 니모닉(mnemonics)이라고 하는 0과 1의 바이너리 패턴을 이해하기 쉽도록 줄임말 형태를 사용하며, 이것이 각 기계어 명령어의 이름입니다. 이 프로그램은 어셈블리 언어 프로그램으로 불리며, 각 컴퓨터의 어셈블리 언어란 컴퓨터의 기계어를 니모닉의 집합으로 표현한 것을 말합니다. 그러므로, 어셈블리 언어는 인간이 컴퓨터를 프로그래밍 할 때 사용되는 가장 낮은 레벨의 언어입니다. 명령의 각 피연산자(operands)는 니모닉 다음에 옵니다. 아래의 예제를 참고해 주세요.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#a6e22e>MOV</span> <span style=color:#a6e22e>R2</span>, <span style=color:#a6e22e>R1</span>
</span></span></code></pre></div><p>이제 우리는 어셈블리 프로그램이 니모닉 이라고 불리우는 언어적 정보의 집합으로 만들어 졌다는 것을 알았으며, 우리는 그것들을 기계어로 변환해야 한다는 사실을 알았습니다. 위에서 언급한 것 처럼 ARM 어셈블리의 경우에는 GNU Binutils 프로젝트에 포함되어 있는 <code>as</code> 명령어를 통해 기계어로 변환할 수 있으며, 이 과정을 어셈블링(assembling) 이라고 부릅니다.</p><p>정리하면, 우리는 컴퓨터가 전기 신호의 존재 여부를 인식하도록 만들어 졌고, 우리는 다양한 신호의 집합을 0과 1(bits)의 집합으로 표현할 수 있다는 사실을 배웠습니다. 우리는 <code>기계어(신호의 집합)</code>를 사용해서 컴퓨터를 미리 설계된 방식으로 작동하도록 제어할 수 있습니다. 우리가 그러한 신호의 집합을 모두 외우고 있기 어려우므로, 줄임말인 <code>니모닉(mnemonics)</code>을 사용하여 각 작동 방식 별로 명령어(이름)를 부여했습니다. 니모닉의 집합을 컴퓨터의 <code>어셈블리 언어</code>라고 부르며 우리는 <code>어셈블러</code> 라고 불리는 프로그램을 사용해서 하이레벨 언어를 위해 컴파일러가 하는 것 처럼 니모닉의 집합을 컴퓨터가 이해할 수 있는 기계어로 변환합니다.</p><h2 id=더-자세히-알아보고-싶다면>더 자세히 알아보고 싶다면..<a hidden class=anchor aria-hidden=true href=#더-자세히-알아보고-싶다면>#</a></h2><ol><li>ARM 어셈블리의 회오리 투어(Whirlwind Tour)</li></ol><p><a href=https://www.coranac.com/tonc/text/asm.htm>https://www.coranac.com/tonc/text/asm.htm</a></p><ol start=2><li>라즈베리파이의 ARM 어셈블러</li></ol><p><a href=http://thinkingeek.com/arm-assembler-raspberry-pi/>http://thinkingeek.com/arm-assembler-raspberry-pi/</a></p><ol start=3><li><p>리버스 엔지니어링 실무: x86, x64, ARM, 윈도우즈 커널, 리버싱 도구, 난독화 (작성자: Bruce Dang, Alexandre Gazet, Elias Bachaalany and Sebastien Josse)</p></li><li><p>ARM 레퍼런스 메뉴얼</p></li></ol><p><a href=http://infocenter.arm.com/help/topic/com.arm.doc.dui0068b/index.html>http://infocenter.arm.com/help/topic/com.arm.doc.dui0068b/index.html</a></p><ol start=5><li>어셈블러 사용자 가이드</li></ol><p><a href=http://www.keil.com/support/man/docs/armasm/default.htm>http://www.keil.com/support/man/docs/armasm/default.htm</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://deguru22.github.io/tags/arm/>ARM</a></li><li><a href=https://deguru22.github.io/tags/assembly/>Assembly</a></li><li><a href=https://deguru22.github.io/tags/tutorial/>Tutorial</a></li></ul><nav class=paginav><a class=prev href=https://deguru22.github.io/2021/08/22/arm-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-2-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85%EA%B3%BC-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0/><span class=title>« Prev Page</span><br><span>ARM 어셈블리 튜토리얼 (2) 데이터 타입과 레지스터</span></a>
<a class=next href=https://deguru22.github.io/2021/07/18/%EC%95%88%EB%85%95/><span class=title>Next Page »</span><br><span>안녕!</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share ARM 어셈블리 튜토리얼 (1) 기초 on twitter" href="https://twitter.com/intent/tweet/?text=ARM%20%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%20%ed%8a%9c%ed%86%a0%eb%a6%ac%ec%96%bc%20%281%29%20%ea%b8%b0%ec%b4%88&url=https%3a%2f%2fdeguru22.github.io%2f2021%2f08%2f18%2farm-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25ED%258A%259C%25ED%2586%25A0%25EB%25A6%25AC%25EC%2596%25BC-1-%25EA%25B8%25B0%25EC%25B4%2588%2f&hashtags=ARM%2cAssembly%2cTutorial"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ARM 어셈블리 튜토리얼 (1) 기초 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdeguru22.github.io%2f2021%2f08%2f18%2farm-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25ED%258A%259C%25ED%2586%25A0%25EB%25A6%25AC%25EC%2596%25BC-1-%25EA%25B8%25B0%25EC%25B4%2588%2f&title=ARM%20%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%20%ed%8a%9c%ed%86%a0%eb%a6%ac%ec%96%bc%20%281%29%20%ea%b8%b0%ec%b4%88&summary=ARM%20%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%20%ed%8a%9c%ed%86%a0%eb%a6%ac%ec%96%bc%20%281%29%20%ea%b8%b0%ec%b4%88&source=https%3a%2f%2fdeguru22.github.io%2f2021%2f08%2f18%2farm-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25ED%258A%259C%25ED%2586%25A0%25EB%25A6%25AC%25EC%2596%25BC-1-%25EA%25B8%25B0%25EC%25B4%2588%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ARM 어셈블리 튜토리얼 (1) 기초 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fdeguru22.github.io%2f2021%2f08%2f18%2farm-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25ED%258A%259C%25ED%2586%25A0%25EB%25A6%25AC%25EC%2596%25BC-1-%25EA%25B8%25B0%25EC%25B4%2588%2f&title=ARM%20%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%20%ed%8a%9c%ed%86%a0%eb%a6%ac%ec%96%bc%20%281%29%20%ea%b8%b0%ec%b4%88"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ARM 어셈블리 튜토리얼 (1) 기초 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fdeguru22.github.io%2f2021%2f08%2f18%2farm-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25ED%258A%259C%25ED%2586%25A0%25EB%25A6%25AC%25EC%2596%25BC-1-%25EA%25B8%25B0%25EC%25B4%2588%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ARM 어셈블리 튜토리얼 (1) 기초 on whatsapp" href="https://api.whatsapp.com/send?text=ARM%20%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%20%ed%8a%9c%ed%86%a0%eb%a6%ac%ec%96%bc%20%281%29%20%ea%b8%b0%ec%b4%88%20-%20https%3a%2f%2fdeguru22.github.io%2f2021%2f08%2f18%2farm-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25ED%258A%259C%25ED%2586%25A0%25EB%25A6%25AC%25EC%2596%25BC-1-%25EA%25B8%25B0%25EC%25B4%2588%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ARM 어셈블리 튜토리얼 (1) 기초 on telegram" href="https://telegram.me/share/url?text=ARM%20%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%20%ed%8a%9c%ed%86%a0%eb%a6%ac%ec%96%bc%20%281%29%20%ea%b8%b0%ec%b4%88&url=https%3a%2f%2fdeguru22.github.io%2f2021%2f08%2f18%2farm-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25ED%258A%259C%25ED%2586%25A0%25EB%25A6%25AC%25EC%2596%25BC-1-%25EA%25B8%25B0%25EC%25B4%2588%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=deguru22/deguru22.github.io issue-term=url label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=https://deguru22.github.io/>데구루루x2 놀이터</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>