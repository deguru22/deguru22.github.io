<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ARM 어셈블리 튜토리얼 (5) 여러 값 불러오기/저장하기 | 데구루루x2 놀이터</title><meta name=keywords content="ARM,Assembly,Tutorial"><meta name=description content="ARM 어셈블리 튜토리얼"><meta name=author content="deguru22"><link rel=canonical href=https://deguru22.github.io/2022/05/08/arm-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-5-%EC%97%AC%EB%9F%AC-%EA%B0%92-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0/%EC%A0%80%EC%9E%A5%ED%95%98%EA%B8%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.min.5e2b4101351c21e906f398ae96901791830f58d430f96f2659dab7eaef7b3cb7.css integrity="sha256-XitBATUcIekG85iulpAXkYMPWNQw+W8mWdq36u97PLc=" rel="preload stylesheet" as=style><link rel=preload href=/images/deguru22.jpg as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://deguru22.github.io/ico/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://deguru22.github.io/ico/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://deguru22.github.io/ico/favicon-32x32.png><link rel=apple-touch-icon href=https://deguru22.github.io/ico/apple-touch-icon.png><link rel=mask-icon href=https://deguru22.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.98.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-164568875-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="ARM 어셈블리 튜토리얼 (5) 여러 값 불러오기/저장하기"><meta property="og:description" content="ARM 어셈블리 튜토리얼"><meta property="og:type" content="article"><meta property="og:url" content="https://deguru22.github.io/2022/05/08/arm-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-5-%EC%97%AC%EB%9F%AC-%EA%B0%92-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0/%EC%A0%80%EC%9E%A5%ED%95%98%EA%B8%B0/"><meta property="og:image" content="https://deguru22.github.io/static/deguru22.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-08T22:20:44+09:00"><meta property="article:modified_time" content="2022-05-08T22:20:44+09:00"><meta property="og:site_name" content="데구루루x2 놀이터"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://deguru22.github.io/static/deguru22.jpg"><meta name=twitter:title content="ARM 어셈블리 튜토리얼 (5) 여러 값 불러오기/저장하기"><meta name=twitter:description content="ARM 어셈블리 튜토리얼"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://deguru22.github.io/posts/"},{"@type":"ListItem","position":2,"name":"ARM 어셈블리 튜토리얼 (5) 여러 값 불러오기/저장하기","item":"https://deguru22.github.io/2022/05/08/arm-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-5-%EC%97%AC%EB%9F%AC-%EA%B0%92-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0/%EC%A0%80%EC%9E%A5%ED%95%98%EA%B8%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ARM 어셈블리 튜토리얼 (5) 여러 값 불러오기/저장하기","name":"ARM 어셈블리 튜토리얼 (5) 여러 값 불러오기\/저장하기","description":"ARM 어셈블리 튜토리얼","keywords":["ARM","Assembly","Tutorial"],"articleBody":"ARM Assembly에 대해 공부하던 중 좋은 글이 있어 번역 하였다.\n출처: Azeria Labs (https://azeria-labs.com/writing-arm-assembly-part-5/)\n 값 불러오기 및 저장하기 가끔은 여러 숫자를 한번에 불러오거나 저장하는 것이 더 효율적일 때가 있습니다. 우리는 LDM(여러개 불러오기)와 STM(여러개 저장하기)를 그런 용도로 사용합니다. 해당 명령어 들은 시작 주소를 접근하는 방법만 다릅니다. 이 파트에서는 아래의 코드를 기반으로 설명할 것입니다. 아래에서 각 명령어 마다 스텝 바이 스텝으로 설명 하겠습니다.\n.data  array_buff:  .word 0x00000000 /* array_buff[0] */  .word 0x00000000 /* array_buff[1] */  .word 0x00000000 /* array_buff[2]. This element has a relative address of array_buff+8 */  .word 0x00000000 /* array_buff[3] */  .word 0x00000000 /* array_buff[4] */  .text .global _start  _start:  adr r0, words+12 /* address of words[3] - r0 */  ldr r1, array_buff_bridge /* address of array_buff[0] - r1 */  ldr r2, array_buff_bridge+4 /* address of array_buff[2] - r2 */  ldm r0, {r4,r5} /* words[3] - r4 = 0x03; words[4] - r5 = 0x04 */  stm r1, {r4,r5} /* r4 - array_buff[0] = 0x03; r5 - array_buff[1] = 0x04 */  ldmia r0, {r4-r6} /* words[3] - r4 = 0x03, words[4] - r5 = 0x04; words[5] - r6 = 0x05; */  stmia r1, {r4-r6} /* r4 - array_buff[0] = 0x03; r5 - array_buff[1] = 0x04; r6 - array_buff[2] = 0x05 */  ldmib r0, {r4-r6} /* words[4] - r4 = 0x04; words[5] - r5 = 0x05; words[6] - r6 = 0x06 */  stmib r1, {r4-r6} /* r4 - array_buff[1] = 0x04; r5 - array_buff[2] = 0x05; r6 - array_buff[3] = 0x06 */  ldmda r0, {r4-r6} /* words[3] - r6 = 0x03; words[2] - r5 = 0x02; words[1] - r4 = 0x01 */  ldmdb r0, {r4-r6} /* words[2] - r6 = 0x02; words[1] - r5 = 0x01; words[0] - r4 = 0x00 */  stmda r2, {r4-r6} /* r6 - array_buff[2] = 0x02; r5 - array_buff[1] = 0x01; r4 - array_buff[0] = 0x00 */  stmdb r2, {r4-r5} /* r5 - array_buff[1] = 0x01; r4 - array_buff[0] = 0x00; */  bx lr  words:  .word 0x00000000 /* words[0] */  .word 0x00000001 /* words[1] */  .word 0x00000002 /* words[2] */  .word 0x00000003 /* words[3] */  .word 0x00000004 /* words[4] */  .word 0x00000005 /* words[5] */  .word 0x00000006 /* words[6] */  array_buff_bridge:  .word array_buff /* address of array_buff, or in other words - array_buff[0] */  .word array_buff+8 /* address of array_buff[2] */ 시작하기 전에, .word는 데이터(메모리)의 32 bits = 4 bytes 블록을 뜻합니다. 이것은 offsetting을 이해하는 데에 매우 중요합니다. 위의 프로그램은 .data 섹션에 5개의 원소를 가진 빈 배열(array_buff)를 선언했습니다. 우리는 이 공간을 데이터 저장하기 위한 작성 가능한 메모리 공간으로 사용할 것입니다. .text 섹션은 코드로 작성된 메모리 연산 명령과 읽기 전용 두 가지 레이블이 존재합니다: 하나는 7개의 원소를 가진 배열이고, 다른것은 .text와 .data 섹션을 이어주는(bridging) 것으로서 우리가 .data 섹션에서 array_buff에 접근 가능하게 해줍니다.\nadr r0, words+12 /* address of words[3] - r0 */ 우리는 ADR 명령어를 사용해서 (게으른 방법) 4번째에 있는 word[3] 원소의 주소를 R0에 집어넣습니다. 단어 배열의 가운데를 지정한 이유는, 해당 위치에서 앞뒤로 연산을 할 것이기 때문입니다.\ngef break _start gef run gef nexti R0는 현재 word[3]을 가리키고 있습니다. 해당 위치는 0x80B8 입니다. 이 말인 즉슨, 우리의 배열 시작점 즉 word[0]의 주소는 0x80AC 라는 것입니다 (0x80B8 - 0xC).\ngef x/7w 0x00080AC 0x80ac : 0x00000000 0x00000001 0x00000002 0x00000003 0x80bc : 0x00000004 0x00000005 0x00000006 우리는 R1과 R2를 배열의 첫번째 원소(array_buff[0])와 세번째 원소(array_buff[2])로 지정해 둡니다. 각각의 주소가 지정되고 나면, 우리가 주소들을 바탕으로 연산을 할 수 있습니다.\nldr r1, array_buff_bridge /* address of array_buff[0] - r1 */ ldr r2, array_buff_bridge+4 /* address of array_buff[2] - r2 */ 위 두 개의 명령어를 실행 시키고 나면, R1과 R2는 array_buff[0]과 array_buff[2]의 주소를 가지게 됩니다.\ngef info register r1 r2 r1 0x100d0 65744 r2 0x100d8 65752 다음 명령어는 LDM을 사용해서 R0가 포인팅 하고있는 메모리 주소에 있는 두개의 워드(word) 값을 불러옵니다. 우리가 R0를 words[3]을 가리키게 했으므로, words[3]의 값이 R4에 저장되고 words[4]의 값은 R5에 저장됩니다.\nldm r0, {r4, r5} /* words[3] - r4 = 0x03; words[4] - r5 = 0x04 */ 2개의 데이터 블록을 하나의 명령어로 불러왔습니다. 그 결과 R4 = 0x00000003, R5 = 0x00000004로 설정된 것을 확인할 수 있습니다.\ngef info registers r4 r5 r4 0x3 3 r5 0x4 4 이제 STM 명령어를 사용해서 여러 값을 메모리에 저장해 보겠습니다. 우리 코드 상의 STM 명령어는 레지스터 R4와 R5의 값을 가지고 가서(0x3과 0x4) R1이 가리키는 메모리 주소에 저장합니다. 우리가 이전에 R1을 array_buff를 가리키도록 설정해 뒀기 때문에, 이 명령어가 실행되고 나면 array_buff[0] = 0x00000003 과 array_buff[1] = 0x00000004가 됩니다. 만약 이렇게 특정돼 있지 않다면, LDM과 SDM은 1개의 word (32 bits = 4 byte) 만큼 움직일 것입니다.\nstm r1, {r4, r5} /* r4 - array_buff[0]=0x03; r5 - array_buff[1]=0x04 */ 해당 값인 0x3과 0x4는 메모리 주소 0x100D0과 0x100D4에 저장될 것입니다. 아래의 명령어를 통해 0x0001000D0에서 부터 두 개의 words 만큼을 출력해 봅시다.\ngef x/2w 0x000100D0 0x100d0 : 0x3 0x4 이전에 언급 했듯이, LDM과 STM은 여러 변종을 가지고 있습니다. 변종들은 명령어의 전치사를 통해 구분할 수 있습니다. 전치사의 예를 들자면: -IA (이후에 더하기), -IB (이전에 더하기), -DA (이후에 빼기), -DB (이전에 빼기) 등이 있습니다. 이러한 변종들은 어떻게 해당 명령어들이 첫 연산자를 기반으로 메모리에 접근 하는지를 표현합니다 (source address를 저장하고 있는 레지스터).\nldmia r0, {r4-r6} /* words[3] - r4=0x03, words[4] - r5 = 0x04; words[5] - r6 = 0x05; */ stmia r1, {r4-r6} /* r4 - array_buff[0] = 0x03; r5 - array_buff[1] = 0x04; r6 - array_buff[2] = 0x05 */ 위의 두 명령을 실행하고 난 후 레지스터 R4-R6과 메모리 주소 0x000100D0, 0x000100D4, 0x000100D8은 0x3, 0x4, 0x5를 값으로 가지게 됩니다.\ngef info registers r4 r5 r6 r4 0x3 3 r5 0x4 4 r6 0x5 5  gef x/3w 0x000100D0 0x100d0 : 0x00000003 0x00000004 0x00000005 LBMIB 명령은 처음 source address를 4 bytes (= 1 word) 만큼 증가 시킨 후 첫 로드를 합니다. 이렇게 해섯 우리는 데이터를 순방향으로 읽을 수 있게 되지만, 첫번째 원소는 source address에서 4 byte 만큼 떨어져서 있게 됩니다. 이것이 우리의 예제에서 LDMIB 명령을 통해 메모리에서 R4로 읽어 들이는 첫 원소가 R0이 가리키는 0x00000003(words[3])이 아닌 0x0000004(words[4])인 이유입니다.\nldmib r0, {r4-r6} /* words[4] - r4 = 0x04; words[5] - r5 = 0x05; words[6] - r6 = 0x06 */ stmib r1, {r4-r6} /* r4 - array_buff[1] = 0x04; r5 - array_buff[2] = 0x05; r6 - array_buff[3] = 0x06 */ 위 두 명령을 실행하고 나면, R4-R6 레지스터의 값과 0x100D4, 0x100D8, 0x100DC 위치에 저장돤 값이 0x4, 0x5, 0x6이 됩니다.\ngef x/3w 0x100D4 0x100d4 : 0x00000004 0x00000005 0x00000006  gef info register r4 r5 r6 r4 0x4 4 r5 0x5 5 r6 0x6 6 LDMDA 명령의 경우는 모든 것을 반대로 연산합니다. R0을 words[3]으로 지정 하겠습니다. 만약 우리가 거꾸로 읽는다 가정했을 때 words[3], words[2], words[1] 을 R6, R5, R4에 불러오게 됩니다. 눈치 채셨듯이, 맞습니다. 레지스터도 똑같이 거꾸로 불러오게 됩니다. 따라서 명령어가 실행 완료 되면 R6 = 0x00000003, R5 = 0x00000002, R4 = 0x00000001 이 됩니다. 그 이유는 우리가 source address를 각각의 불러오기 행위 이후에 감소 연산이 진행되기 때문입니다. 거꾸로 읽기 행위가 일어나는 이유는 우리가 각각의 메모리 주소를 불러올 때 마다 감소 연산을 같이 진행 하기 때문에, 레지스트리 숫자도 줄어들면서 높은 메모리 주소가 높은 레지스트리 숫자를 가져야 한다는 논리를 따르기 때문입니다. LDMIA(혹은 LDM) 명령어 예제를 보면, 우리는 낮은 레지스트리를 먼저 부릅니다. 왜냐면 source address 가 낮기 때문이며, 그 후에 높은 레지스트리를 부르는데 왜냐면 source address가 증가했기 때문입니다.\n여러 개를 불러온 후에 감소시키는 경우는:\nldmda r0, {r4-r6} /* words[3] - r6 = 0x03; words[2] - r5 = 0x02; words[1] - r4 = 0x01 */ 위 명령 실행 후 레지스터 R4, R5, R6는:\ngef info register r4 r5 r6 r4 0x1 1 r5 0x2 2 r6 0x3 3 여러개 불러 오기 이전에 감소하는 경우는:\nldmdb r0, {r4-r6} /* words[2]-r6 = 0x02; words[1]-r5 = 0x01; words[1]-r4 = 0x01 */ 위 명령 실행 후 레지스터 R4, R5, R6는:\ngef info register r4 r5 r6 r4 0x0 0 r5 0x1 1 r6 0x2 2 여러개 저장한 후 감소시키는 경우는:\nstmda r2, {r4-r6} /* r6-array_buff[2] = 0x02; r5-array_buff[1] = 0x01; r4-array_buff[0] = 0x00 */ 명령 실행 후 array_buff[2], array_buff[1], array_buff[0]의 메모리 주소는:\ngef x/3w 0x100D0 0x100d0 : 0x00000000 0x00000001 0x00000002 미리 감소 후 여러개 저장하는 경우는:\nstmdb r2, {r4-r5} /* r5-array_buff[1] = 0x01; r4-array_buff[0] = 0x00; */ 명령 실행 후 array_buff[1]과 array_buff[0]의 메모리 주소는:\ngef x/2w 0x100D0 0x100d0 : 0x00000000 0x00000001 PUSH와 POP 메모리 위치 중 스택으로 불리는 프로세스가 있습니다. 스택 포인터(SP)는 일반적인 상황에서 언제나 스택의 메모리 위치를 가리키는 레지스터 입니다. 어플리케이션은 주로 스택을 임시 데이터 저장소로 사용합니다. 이전에 언급 했듯이, ARM은 불러오기/저장하기 모델을 통해 메모리에 접근합니다. 이말인 즉슨 LDR / STR 명령 혹은 그들의 지시자(LDM.. / STM..)을 메모리 연산에 사용한다는 것입니다. x86에서는 PUSH와 POP을 스택에 값을 넣거나 뺄때 사용합니다. ARM에서 우리도 이 두개의 명령어를 사용할 수 있습니다.\n우리가 완전 내림차순으로 뭔가를 스택에 PUSH 할때는(스택에 대해 다른점을 더 알고싶다면 Part 7: 스택과 함수 를 참고하세요) 아래와 같은 일이 일어납니다:\n 첫번째로, SP의 주소는 4만큼 줄어듭니다. 두번째로, SP가 가리키는 새로운 메모리 주소에 정보가 저장됩니다.  우리가 뭔가를 스택에서 POP할때는 아래와 같은 일이 일어납니다:\n 현재 SP의 주소를 특정 레지스터에 불러옵니다. SP의 주소가 4만큼 늘어납니다.  아래 예제에서는 PUSH/POP과 LDMIA/STMDB를 사용하고 있습니다.\n.text .global _start  _start:  mov r0, #3  mov r1, #4  push {r0, r1}  pop {r2, r3}  stmdb sp!, {r0, r1}  ldmia sp!, {r4, r5}  bkpt 이 코드를 디스어셈블리해서 한번 봅시다.\nazeria@labs:~$ as pushpop.s -o pushpop.o azeria@labs:~$ ld pushpop.o -o pushpop azeria@labs:~$ objdump -D pushpop pushpop: file format elf32-littlearm  Disassembly of section .text:  00008054 :  8054: e3a00003 mov r0, #3  8058: e3a01004 mov r1, #4  805c: e92d0003 push {r0, r1}  8060: e8bd000c pop {r2, r3}  8064: e92d0003 push {r0, r1}  8068: e8bd0030 pop {r4, r5}  806c: e1200070 bkpt 0x0000 위에서 볼 수 있듯이, LDMIA와 STMDB 명령어는 PUSH와 POP로 해석되었습니다. 왜냐하면 STMDB sp!, reglist는 PUSH와 동의어이고 LDMIA sp! reglist는 LDMIA와 동의어이기 때문입니다(참고: ARM 매뉴얼).\n이 코드를 GDB에서 실행해 봅시다.\ngef break _start gef run gef nexti 2 [...] gef x/w $sp 0xbefff7e0: 0x00000001 위 두개의 명령어를 실행하고 난 뒤 SP가 어떤 메모리 주소를 가리키고 있는지 확인해 보겠습니다. 다음 PUSH 명령어는 SP를 8만큼 감소 시켜야 하며, R1과 R0의 자료를 나열한 순서에 맞게 스택에 저장하게 됩니다.\ngef nexti [...] ----- Stack ----- 0xbefff7d8|+0x00: 0x3 0xbefff7dc|+0x04: 0x4 0xbefff7e0|+0x08: 0x1 [...] gef x/w $sp 0xbefff7d8: 0x00000003 다음으로는, 이 두개의 값(0x3, 0x4)를 레지스터로 POP 해서 R2=0x3, R3=0x4가 됩니다. SP는 8만큼 증가합니다.\n","wordCount":"1631","inLanguage":"en","datePublished":"2022-05-08T22:20:44+09:00","dateModified":"2022-05-08T22:20:44+09:00","author":{"@type":"Person","name":"deguru22"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://deguru22.github.io/2022/05/08/arm-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-5-%EC%97%AC%EB%9F%AC-%EA%B0%92-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0/%EC%A0%80%EC%9E%A5%ED%95%98%EA%B8%B0/"},"publisher":{"@type":"Organization","name":"데구루루x2 놀이터","logo":{"@type":"ImageObject","url":"https://deguru22.github.io/ico/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://deguru22.github.io/ accesskey=h title="데구루루x2 놀이터 (Alt + H)"><img src=/images/deguru22.jpg alt=logo aria-label=logo height=35>데구루루x2 놀이터</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://deguru22.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://deguru22.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://deguru22.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://deguru22.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://deguru22.github.io/posts/>Posts</a></div><h1 class=post-title>ARM 어셈블리 튜토리얼 (5) 여러 값 불러오기/저장하기</h1><div class=post-description>ARM 어셈블리 튜토리얼</div><div class=post-meta>May 8, 2022&nbsp;·&nbsp;8 min&nbsp;·&nbsp;deguru22&nbsp;|&nbsp;<a href=https://github.com/deguru22/deguru22.github.io/content/posts/arm-assembly-5.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ea%b0%92-%eb%b6%88%eb%9f%ac%ec%98%a4%ea%b8%b0-%eb%b0%8f-%ec%a0%80%ec%9e%a5%ed%95%98%ea%b8%b0 aria-label="값 불러오기 및 저장하기">값 불러오기 및 저장하기</a></li><li><a href=#push%ec%99%80-pop aria-label="PUSH와 POP">PUSH와 POP</a></li></ul></div></details></div><div class=post-content><p>ARM Assembly에 대해 공부하던 중 좋은 글이 있어 번역 하였다.</p><p>출처: Azeria Labs (<a href=https://azeria-labs.com/writing-arm-assembly-part-5/>https://azeria-labs.com/writing-arm-assembly-part-5/</a>)</p><hr><h2 id=값-불러오기-및-저장하기>값 불러오기 및 저장하기<a hidden class=anchor aria-hidden=true href=#값-불러오기-및-저장하기>#</a></h2><p>가끔은 여러 숫자를 한번에 불러오거나 저장하는 것이 더 효율적일 때가 있습니다. 우리는 LDM(여러개 불러오기)와 STM(여러개 저장하기)를 그런 용도로 사용합니다. 해당 명령어 들은 시작 주소를 접근하는 방법만 다릅니다. 이 파트에서는 아래의 코드를 기반으로 설명할 것입니다. 아래에서 각 명령어 마다 스텝 바이 스텝으로 설명 하겠습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>.data
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>array_buff:
</span></span><span style=display:flex><span> .word 0x00000000             /* array_buff<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> */
</span></span><span style=display:flex><span> .word 0x00000000             /* array_buff<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> */
</span></span><span style=display:flex><span> .word 0x00000000             /* array_buff<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span>. This element has a relative address of array_buff+8 */
</span></span><span style=display:flex><span> .word 0x00000000             /* array_buff<span style=color:#f92672>[</span>3<span style=color:#f92672>]</span> */
</span></span><span style=display:flex><span> .word 0x00000000             /* array_buff<span style=color:#f92672>[</span>4<span style=color:#f92672>]</span> */
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.text
</span></span><span style=display:flex><span>.global _start
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>_start:
</span></span><span style=display:flex><span> adr r0, words+12             /* address of words<span style=color:#f92672>[</span>3<span style=color:#f92672>]</span> -&gt; r0 */
</span></span><span style=display:flex><span> ldr r1, array_buff_bridge    /* address of array_buff<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> -&gt; r1 */
</span></span><span style=display:flex><span> ldr r2, array_buff_bridge+4  /* address of array_buff<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span> -&gt; r2 */
</span></span><span style=display:flex><span> ldm r0, <span style=color:#f92672>{</span>r4,r5<span style=color:#f92672>}</span>              /* words<span style=color:#f92672>[</span>3<span style=color:#f92672>]</span> -&gt; r4 <span style=color:#f92672>=</span> 0x03; words<span style=color:#f92672>[</span>4<span style=color:#f92672>]</span> -&gt; r5 <span style=color:#f92672>=</span> 0x04 */
</span></span><span style=display:flex><span> stm r1, <span style=color:#f92672>{</span>r4,r5<span style=color:#f92672>}</span>              /* r4 -&gt; array_buff<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0x03; r5 -&gt; array_buff<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0x04 */
</span></span><span style=display:flex><span> ldmia r0, <span style=color:#f92672>{</span>r4-r6<span style=color:#f92672>}</span>            /* words<span style=color:#f92672>[</span>3<span style=color:#f92672>]</span> -&gt; r4 <span style=color:#f92672>=</span> 0x03, words<span style=color:#f92672>[</span>4<span style=color:#f92672>]</span> -&gt; r5 <span style=color:#f92672>=</span> 0x04; words<span style=color:#f92672>[</span>5<span style=color:#f92672>]</span> -&gt; r6 <span style=color:#f92672>=</span> 0x05; */
</span></span><span style=display:flex><span> stmia r1, <span style=color:#f92672>{</span>r4-r6<span style=color:#f92672>}</span>            /* r4 -&gt; array_buff<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0x03; r5 -&gt; array_buff<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0x04; r6 -&gt; array_buff<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0x05 */
</span></span><span style=display:flex><span> ldmib r0, <span style=color:#f92672>{</span>r4-r6<span style=color:#f92672>}</span>            /* words<span style=color:#f92672>[</span>4<span style=color:#f92672>]</span> -&gt; r4 <span style=color:#f92672>=</span> 0x04; words<span style=color:#f92672>[</span>5<span style=color:#f92672>]</span> -&gt; r5 <span style=color:#f92672>=</span> 0x05; words<span style=color:#f92672>[</span>6<span style=color:#f92672>]</span> -&gt; r6 <span style=color:#f92672>=</span> 0x06 */
</span></span><span style=display:flex><span> stmib r1, <span style=color:#f92672>{</span>r4-r6<span style=color:#f92672>}</span>            /* r4 -&gt; array_buff<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0x04; r5 -&gt; array_buff<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0x05; r6 -&gt; array_buff<span style=color:#f92672>[</span>3<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0x06 */
</span></span><span style=display:flex><span> ldmda r0, <span style=color:#f92672>{</span>r4-r6<span style=color:#f92672>}</span>            /* words<span style=color:#f92672>[</span>3<span style=color:#f92672>]</span> -&gt; r6 <span style=color:#f92672>=</span> 0x03; words<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span> -&gt; r5 <span style=color:#f92672>=</span> 0x02; words<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> -&gt; r4 <span style=color:#f92672>=</span> 0x01 */
</span></span><span style=display:flex><span> ldmdb r0, <span style=color:#f92672>{</span>r4-r6<span style=color:#f92672>}</span>            /* words<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span> -&gt; r6 <span style=color:#f92672>=</span> 0x02; words<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> -&gt; r5 <span style=color:#f92672>=</span> 0x01; words<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> -&gt; r4 <span style=color:#f92672>=</span> 0x00 */
</span></span><span style=display:flex><span> stmda r2, <span style=color:#f92672>{</span>r4-r6<span style=color:#f92672>}</span>            /* r6 -&gt; array_buff<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0x02; r5 -&gt; array_buff<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0x01; r4 -&gt; array_buff<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0x00 */
</span></span><span style=display:flex><span> stmdb r2, <span style=color:#f92672>{</span>r4-r5<span style=color:#f92672>}</span>            /* r5 -&gt; array_buff<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0x01; r4 -&gt; array_buff<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0x00; */
</span></span><span style=display:flex><span> bx lr
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>words:
</span></span><span style=display:flex><span> .word 0x00000000             /* words<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> */
</span></span><span style=display:flex><span> .word 0x00000001             /* words<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> */
</span></span><span style=display:flex><span> .word 0x00000002             /* words<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span> */
</span></span><span style=display:flex><span> .word 0x00000003             /* words<span style=color:#f92672>[</span>3<span style=color:#f92672>]</span> */
</span></span><span style=display:flex><span> .word 0x00000004             /* words<span style=color:#f92672>[</span>4<span style=color:#f92672>]</span> */
</span></span><span style=display:flex><span> .word 0x00000005             /* words<span style=color:#f92672>[</span>5<span style=color:#f92672>]</span> */
</span></span><span style=display:flex><span> .word 0x00000006             /* words<span style=color:#f92672>[</span>6<span style=color:#f92672>]</span> */
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>array_buff_bridge:
</span></span><span style=display:flex><span> .word array_buff             /* address of array_buff, or in other words - array_buff<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> */
</span></span><span style=display:flex><span> .word array_buff+8           /* address of array_buff<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span> */
</span></span></code></pre></div><p>시작하기 전에, .word는 데이터(메모리)의 32 bits = 4 bytes 블록을 뜻합니다. 이것은 offsetting을 이해하는 데에 매우 중요합니다. 위의 프로그램은 .data 섹션에 5개의 원소를 가진 빈 배열(array_buff)를 선언했습니다. 우리는 이 공간을 데이터 저장하기 위한 작성 가능한 메모리 공간으로 사용할 것입니다. .text 섹션은 코드로 작성된 메모리 연산 명령과 읽기 전용 두 가지 레이블이 존재합니다: 하나는 7개의 원소를 가진 배열이고, 다른것은 .text와 .data 섹션을 이어주는(bridging) 것으로서 우리가 .data 섹션에서 array_buff에 접근 가능하게 해줍니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>adr r0, words+12     /* address of words<span style=color:#f92672>[</span>3<span style=color:#f92672>]</span> -&gt; r0 */
</span></span></code></pre></div><p>우리는 ADR 명령어를 사용해서 (게으른 방법) 4번째에 있는 word[3] 원소의 주소를 R0에 집어넣습니다. 단어 배열의 가운데를 지정한 이유는, 해당 위치에서 앞뒤로 연산을 할 것이기 때문입니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>gef&gt; break _start
</span></span><span style=display:flex><span>gef&gt; run
</span></span><span style=display:flex><span>gef&gt; nexti
</span></span></code></pre></div><p>R0는 현재 word[3]을 가리키고 있습니다. 해당 위치는 0x80B8 입니다. 이 말인 즉슨, 우리의 배열 시작점 즉 word[0]의 주소는 0x80AC 라는 것입니다 (0x80B8 - 0xC).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>gef&gt; x/7w 0x00080AC
</span></span><span style=display:flex><span>0x80ac &lt;words&gt;: 0x00000000 0x00000001 0x00000002 0x00000003
</span></span><span style=display:flex><span>0x80bc &lt;words+16&gt;: 0x00000004 0x00000005 0x00000006
</span></span></code></pre></div><p>우리는 R1과 R2를 배열의 첫번째 원소(array_buff[0])와 세번째 원소(array_buff[2])로 지정해 둡니다. 각각의 주소가 지정되고 나면, 우리가 주소들을 바탕으로 연산을 할 수 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ldr r1, array_buff_bridge   /* address of array_buff<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> -&gt; r1 */
</span></span><span style=display:flex><span>ldr r2, array_buff_bridge+4 /* address of array_buff<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span> -&gt; r2 */
</span></span></code></pre></div><p>위 두 개의 명령어를 실행 시키고 나면, R1과 R2는 array_buff[0]과 array_buff[2]의 주소를 가지게 됩니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>gef&gt; info register r1 r2
</span></span><span style=display:flex><span>r1    0x100d0    <span style=color:#ae81ff>65744</span>
</span></span><span style=display:flex><span>r2    0x100d8    <span style=color:#ae81ff>65752</span>
</span></span></code></pre></div><p>다음 명령어는 LDM을 사용해서 R0가 포인팅 하고있는 메모리 주소에 있는 두개의 워드(word) 값을 불러옵니다. 우리가 R0를 words[3]을 가리키게 했으므로, words[3]의 값이 R4에 저장되고 words[4]의 값은 R5에 저장됩니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ldm r0, <span style=color:#f92672>{</span>r4, r5<span style=color:#f92672>}</span>           /* words<span style=color:#f92672>[</span>3<span style=color:#f92672>]</span> -&gt; r4 <span style=color:#f92672>=</span> 0x03; words<span style=color:#f92672>[</span>4<span style=color:#f92672>]</span> -&gt; r5 <span style=color:#f92672>=</span> 0x04 */
</span></span></code></pre></div><p>2개의 데이터 블록을 하나의 명령어로 불러왔습니다. 그 결과 R4 = 0x00000003, R5 = 0x00000004로 설정된 것을 확인할 수 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>gef&gt; info registers r4 r5
</span></span><span style=display:flex><span>r4     0x3     <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>r5     0x4     <span style=color:#ae81ff>4</span> 
</span></span></code></pre></div><p>이제 STM 명령어를 사용해서 여러 값을 메모리에 저장해 보겠습니다. 우리 코드 상의 STM 명령어는 레지스터 R4와 R5의 값을 가지고 가서(0x3과 0x4) R1이 가리키는 메모리 주소에 저장합니다. 우리가 이전에 R1을 array_buff를 가리키도록 설정해 뒀기 때문에, 이 명령어가 실행되고 나면 array_buff[0] = 0x00000003 과 array_buff[1] = 0x00000004가 됩니다. 만약 이렇게 특정돼 있지 않다면, LDM과 SDM은 1개의 word (32 bits = 4 byte) 만큼 움직일 것입니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>stm r1, <span style=color:#f92672>{</span>r4, r5<span style=color:#f92672>}</span>          /* r4 -&gt; array_buff<span style=color:#f92672>[</span>0<span style=color:#f92672>]=</span>0x03; r5 - array_buff<span style=color:#f92672>[</span>1<span style=color:#f92672>]=</span>0x04 */
</span></span></code></pre></div><p>해당 값인 0x3과 0x4는 메모리 주소 0x100D0과 0x100D4에 저장될 것입니다. 아래의 명령어를 통해 0x0001000D0에서 부터 두 개의 words 만큼을 출력해 봅시다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>gef&gt; x/2w 0x000100D0
</span></span><span style=display:flex><span>0x100d0 &lt;array_buff&gt;: 0x3 0x4
</span></span></code></pre></div><p>이전에 언급 했듯이, LDM과 STM은 여러 변종을 가지고 있습니다. 변종들은 명령어의 전치사를 통해 구분할 수 있습니다. 전치사의 예를 들자면: -IA (이후에 더하기), -IB (이전에 더하기), -DA (이후에 빼기), -DB (이전에 빼기) 등이 있습니다. 이러한 변종들은 어떻게 해당 명령어들이 첫 연산자를 기반으로 메모리에 접근 하는지를 표현합니다 (source address를 저장하고 있는 레지스터).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ldmia r0, <span style=color:#f92672>{</span>r4-r6<span style=color:#f92672>}</span> /* words<span style=color:#f92672>[</span>3<span style=color:#f92672>]</span> -&gt; r4<span style=color:#f92672>=</span>0x03, words<span style=color:#f92672>[</span>4<span style=color:#f92672>]</span> -&gt; r5 <span style=color:#f92672>=</span> 0x04; words<span style=color:#f92672>[</span>5<span style=color:#f92672>]</span> -&gt; r6 <span style=color:#f92672>=</span> 0x05; */
</span></span><span style=display:flex><span>stmia r1, <span style=color:#f92672>{</span>r4-r6<span style=color:#f92672>}</span> /* r4 -&gt; array_buff<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0x03; r5 -&gt; array_buff<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0x04; r6 -&gt; array_buff<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0x05 */
</span></span></code></pre></div><p>위의 두 명령을 실행하고 난 후 레지스터 R4-R6과 메모리 주소 0x000100D0, 0x000100D4, 0x000100D8은 0x3, 0x4, 0x5를 값으로 가지게 됩니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>gef&gt; info registers r4 r5 r6
</span></span><span style=display:flex><span>r4   0x3   <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>r5   0x4   <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>r6   0x5   <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>gef&gt; x/3w 0x000100D0
</span></span><span style=display:flex><span>0x100d0 &lt;array_buff&gt;: 0x00000003 0x00000004 0x00000005
</span></span></code></pre></div><p>LBMIB 명령은 처음 source address를 4 bytes (= 1 word) 만큼 증가 시킨 후 첫 로드를 합니다. 이렇게 해섯 우리는 데이터를 순방향으로 읽을 수 있게 되지만, 첫번째 원소는 source address에서 4 byte 만큼 떨어져서 있게 됩니다. 이것이 우리의 예제에서 LDMIB 명령을 통해 메모리에서 R4로 읽어 들이는 첫 원소가 R0이 가리키는 0x00000003(words[3])이 아닌 0x0000004(words[4])인 이유입니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ldmib r0, <span style=color:#f92672>{</span>r4-r6<span style=color:#f92672>}</span>   /* words<span style=color:#f92672>[</span>4<span style=color:#f92672>]</span> -&gt; r4 <span style=color:#f92672>=</span> 0x04; words<span style=color:#f92672>[</span>5<span style=color:#f92672>]</span> -&gt; r5 <span style=color:#f92672>=</span> 0x05; words<span style=color:#f92672>[</span>6<span style=color:#f92672>]</span> -&gt; r6 <span style=color:#f92672>=</span> 0x06 */
</span></span><span style=display:flex><span>stmib r1, <span style=color:#f92672>{</span>r4-r6<span style=color:#f92672>}</span>   /* r4 -&gt; array_buff<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0x04; r5 -&gt; array_buff<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0x05; r6 -&gt; array_buff<span style=color:#f92672>[</span>3<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0x06 */
</span></span></code></pre></div><p>위 두 명령을 실행하고 나면, R4-R6 레지스터의 값과 0x100D4, 0x100D8, 0x100DC 위치에 저장돤 값이 0x4, 0x5, 0x6이 됩니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>gef&gt; x/3w 0x100D4
</span></span><span style=display:flex><span>0x100d4 &lt;array_buff+4&gt;: 0x00000004 0x00000005 0x00000006
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>gef&gt; info register r4 r5 r6
</span></span><span style=display:flex><span>r4   0x4   <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>r5   0x5   <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>r6   0x6   <span style=color:#ae81ff>6</span>
</span></span></code></pre></div><p>LDMDA 명령의 경우는 모든 것을 반대로 연산합니다. R0을 words[3]으로 지정 하겠습니다. 만약 우리가 거꾸로 읽는다 가정했을 때 words[3], words[2], words[1] 을 R6, R5, R4에 불러오게 됩니다. 눈치 채셨듯이, 맞습니다. 레지스터도 똑같이 거꾸로 불러오게 됩니다. 따라서 명령어가 실행 완료 되면 R6 = 0x00000003, R5 = 0x00000002, R4 = 0x00000001 이 됩니다. 그 이유는 우리가 source address를 각각의 불러오기 행위 이후에 감소 연산이 진행되기 때문입니다. 거꾸로 읽기 행위가 일어나는 이유는 우리가 각각의 메모리 주소를 불러올 때 마다 감소 연산을 같이 진행 하기 때문에, 레지스트리 숫자도 줄어들면서 높은 메모리 주소가 높은 레지스트리 숫자를 가져야 한다는 논리를 따르기 때문입니다. LDMIA(혹은 LDM) 명령어 예제를 보면, 우리는 낮은 레지스트리를 먼저 부릅니다. 왜냐면 source address 가 낮기 때문이며, 그 후에 높은 레지스트리를 부르는데 왜냐면 source address가 증가했기 때문입니다.</p><p>여러 개를 불러온 후에 감소시키는 경우는:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ldmda r0, <span style=color:#f92672>{</span>r4-r6<span style=color:#f92672>}</span> /* words<span style=color:#f92672>[</span>3<span style=color:#f92672>]</span> -&gt; r6 <span style=color:#f92672>=</span> 0x03; words<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span> -&gt; r5 <span style=color:#f92672>=</span> 0x02; words<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> -&gt; r4 <span style=color:#f92672>=</span> 0x01 */
</span></span></code></pre></div><p>위 명령 실행 후 레지스터 R4, R5, R6는:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>gef&gt; info register r4 r5 r6
</span></span><span style=display:flex><span>r4    0x1    <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>r5    0x2    <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>r6    0x3    <span style=color:#ae81ff>3</span>
</span></span></code></pre></div><p>여러개 불러 오기 이전에 감소하는 경우는:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ldmdb r0, <span style=color:#f92672>{</span>r4-r6<span style=color:#f92672>}</span> /* words<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span>-&gt;r6 <span style=color:#f92672>=</span> 0x02; words<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>-&gt;r5 <span style=color:#f92672>=</span> 0x01; words<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>-&gt;r4 <span style=color:#f92672>=</span> 0x01 */ 
</span></span></code></pre></div><p>위 명령 실행 후 레지스터 R4, R5, R6는:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>gef&gt; info register r4 r5 r6
</span></span><span style=display:flex><span>r4    0x0    <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>r5    0x1    <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>r6    0x2    <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><p>여러개 저장한 후 감소시키는 경우는:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>stmda r2, <span style=color:#f92672>{</span>r4-r6<span style=color:#f92672>}</span> /* r6-&gt;array_buff<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0x02; r5-&gt;array_buff<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0x01; r4-&gt;array_buff<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0x00 */
</span></span></code></pre></div><p>명령 실행 후 array_buff[2], array_buff[1], array_buff[0]의 메모리 주소는:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>gef&gt; x/3w 0x100D0
</span></span><span style=display:flex><span>0x100d0 &lt;array_buff&gt;: 0x00000000 0x00000001 0x00000002
</span></span></code></pre></div><p>미리 감소 후 여러개 저장하는 경우는:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>stmdb r2, <span style=color:#f92672>{</span>r4-r5<span style=color:#f92672>}</span> /* r5-&gt;array_buff<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0x01; r4-&gt;array_buff<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0x00; */
</span></span></code></pre></div><p>명령 실행 후 array_buff[1]과 array_buff[0]의 메모리 주소는:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>gef&gt; x/2w 0x100D0
</span></span><span style=display:flex><span>0x100d0 &lt;array_buff&gt;: 0x00000000 0x00000001
</span></span></code></pre></div><h2 id=push와-pop>PUSH와 POP<a hidden class=anchor aria-hidden=true href=#push와-pop>#</a></h2><p>메모리 위치 중 스택으로 불리는 프로세스가 있습니다. 스택 포인터(SP)는 일반적인 상황에서 언제나 스택의 메모리 위치를 가리키는 레지스터 입니다. 어플리케이션은 주로 스택을 임시 데이터 저장소로 사용합니다. 이전에 언급 했듯이, ARM은 불러오기/저장하기 모델을 통해 메모리에 접근합니다. 이말인 즉슨 LDR / STR 명령 혹은 그들의 지시자(LDM.. / STM..)을 메모리 연산에 사용한다는 것입니다. x86에서는 PUSH와 POP을 스택에 값을 넣거나 뺄때 사용합니다. ARM에서 우리도 이 두개의 명령어를 사용할 수 있습니다.</p><p>우리가 완전 내림차순으로 뭔가를 스택에 PUSH 할때는(스택에 대해 다른점을 더 알고싶다면 Part 7: 스택과 함수 를 참고하세요) 아래와 같은 일이 일어납니다:</p><ol><li>첫번째로, SP의 주소는 4만큼 줄어듭니다.</li><li>두번째로, SP가 가리키는 새로운 메모리 주소에 정보가 저장됩니다.</li></ol><p>우리가 뭔가를 스택에서 POP할때는 아래와 같은 일이 일어납니다:</p><ol><li>현재 SP의 주소를 특정 레지스터에 불러옵니다.</li><li>SP의 주소가 4만큼 늘어납니다.</li></ol><p>아래 예제에서는 PUSH/POP과 LDMIA/STMDB를 사용하고 있습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>.text
</span></span><span style=display:flex><span>.global _start
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>_start:
</span></span><span style=display:flex><span>   mov r0, <span style=color:#75715e>#3</span>
</span></span><span style=display:flex><span>   mov r1, <span style=color:#75715e>#4</span>
</span></span><span style=display:flex><span>   push <span style=color:#f92672>{</span>r0, r1<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>   pop <span style=color:#f92672>{</span>r2, r3<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>   stmdb sp!, <span style=color:#f92672>{</span>r0, r1<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>   ldmia sp!, <span style=color:#f92672>{</span>r4, r5<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>   bkpt
</span></span></code></pre></div><p>이 코드를 디스어셈블리해서 한번 봅시다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>azeria@labs:~$ as pushpop.s -o pushpop.o
</span></span><span style=display:flex><span>azeria@labs:~$ ld pushpop.o -o pushpop
</span></span><span style=display:flex><span>azeria@labs:~$ objdump -D pushpop
</span></span><span style=display:flex><span>pushpop: file format elf32-littlearm
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Disassembly of section .text:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>00008054</span> &lt;_start&gt;:
</span></span><span style=display:flex><span> 8054: e3a00003 mov r0, <span style=color:#75715e>#3</span>
</span></span><span style=display:flex><span> 8058: e3a01004 mov r1, <span style=color:#75715e>#4</span>
</span></span><span style=display:flex><span> 805c: e92d0003 push <span style=color:#f92672>{</span>r0, r1<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span> 8060: e8bd000c pop <span style=color:#f92672>{</span>r2, r3<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span> 8064: e92d0003 push <span style=color:#f92672>{</span>r0, r1<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span> 8068: e8bd0030 pop <span style=color:#f92672>{</span>r4, r5<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span> 806c: e1200070 bkpt 0x0000
</span></span></code></pre></div><p>위에서 볼 수 있듯이, LDMIA와 STMDB 명령어는 PUSH와 POP로 해석되었습니다. 왜냐하면 STMDB sp!, reglist는 PUSH와 동의어이고 LDMIA sp! reglist는 LDMIA와 동의어이기 때문입니다(참고: <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0489e/Babefbce.html">ARM 매뉴얼</a>).</p><p>이 코드를 GDB에서 실행해 봅시다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>gef&gt; break _start
</span></span><span style=display:flex><span>gef&gt; run
</span></span><span style=display:flex><span>gef&gt; nexti <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>...<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>gef&gt; x/w $sp
</span></span><span style=display:flex><span>0xbefff7e0: 0x00000001
</span></span></code></pre></div><p>위 두개의 명령어를 실행하고 난 뒤 SP가 어떤 메모리 주소를 가리키고 있는지 확인해 보겠습니다. 다음 PUSH 명령어는 SP를 8만큼 감소 시켜야 하며, R1과 R0의 자료를 나열한 순서에 맞게 스택에 저장하게 됩니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>gef&gt; nexti
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>...<span style=color:#f92672>]</span> ----- Stack -----
</span></span><span style=display:flex><span>0xbefff7d8|+0x00: 0x3 &lt;- $sp
</span></span><span style=display:flex><span>0xbefff7dc|+0x04: 0x4
</span></span><span style=display:flex><span>0xbefff7e0|+0x08: 0x1
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>...<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>gef&gt; x/w $sp
</span></span><span style=display:flex><span>0xbefff7d8: 0x00000003
</span></span></code></pre></div><p>다음으로는, 이 두개의 값(0x3, 0x4)를 레지스터로 POP 해서 R2=0x3, R3=0x4가 됩니다. SP는 8만큼 증가합니다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://deguru22.github.io/tags/arm/>ARM</a></li><li><a href=https://deguru22.github.io/tags/assembly/>Assembly</a></li><li><a href=https://deguru22.github.io/tags/tutorial/>Tutorial</a></li></ul><nav class=paginav><a class=next href=https://deguru22.github.io/2021/09/22/uri-scheme%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-%EA%B3%B5%EA%B2%A9-aws-workspace-rce-macos-finder-rce/><span class=title>Next Page »</span><br><span>URI Scheme을 활용한 공격 - AWS Workspace RCE, macOS Finder RCE</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share ARM 어셈블리 튜토리얼 (5) 여러 값 불러오기/저장하기 on twitter" href="https://twitter.com/intent/tweet/?text=ARM%20%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%20%ed%8a%9c%ed%86%a0%eb%a6%ac%ec%96%bc%20%285%29%20%ec%97%ac%eb%9f%ac%20%ea%b0%92%20%eb%b6%88%eb%9f%ac%ec%98%a4%ea%b8%b0%2f%ec%a0%80%ec%9e%a5%ed%95%98%ea%b8%b0&url=https%3a%2f%2fdeguru22.github.io%2f2022%2f05%2f08%2farm-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25ED%258A%259C%25ED%2586%25A0%25EB%25A6%25AC%25EC%2596%25BC-5-%25EC%2597%25AC%25EB%259F%25AC-%25EA%25B0%2592-%25EB%25B6%2588%25EB%259F%25AC%25EC%2598%25A4%25EA%25B8%25B0%2f%25EC%25A0%2580%25EC%259E%25A5%25ED%2595%2598%25EA%25B8%25B0%2f&hashtags=ARM%2cAssembly%2cTutorial"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ARM 어셈블리 튜토리얼 (5) 여러 값 불러오기/저장하기 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdeguru22.github.io%2f2022%2f05%2f08%2farm-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25ED%258A%259C%25ED%2586%25A0%25EB%25A6%25AC%25EC%2596%25BC-5-%25EC%2597%25AC%25EB%259F%25AC-%25EA%25B0%2592-%25EB%25B6%2588%25EB%259F%25AC%25EC%2598%25A4%25EA%25B8%25B0%2f%25EC%25A0%2580%25EC%259E%25A5%25ED%2595%2598%25EA%25B8%25B0%2f&title=ARM%20%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%20%ed%8a%9c%ed%86%a0%eb%a6%ac%ec%96%bc%20%285%29%20%ec%97%ac%eb%9f%ac%20%ea%b0%92%20%eb%b6%88%eb%9f%ac%ec%98%a4%ea%b8%b0%2f%ec%a0%80%ec%9e%a5%ed%95%98%ea%b8%b0&summary=ARM%20%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%20%ed%8a%9c%ed%86%a0%eb%a6%ac%ec%96%bc%20%285%29%20%ec%97%ac%eb%9f%ac%20%ea%b0%92%20%eb%b6%88%eb%9f%ac%ec%98%a4%ea%b8%b0%2f%ec%a0%80%ec%9e%a5%ed%95%98%ea%b8%b0&source=https%3a%2f%2fdeguru22.github.io%2f2022%2f05%2f08%2farm-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25ED%258A%259C%25ED%2586%25A0%25EB%25A6%25AC%25EC%2596%25BC-5-%25EC%2597%25AC%25EB%259F%25AC-%25EA%25B0%2592-%25EB%25B6%2588%25EB%259F%25AC%25EC%2598%25A4%25EA%25B8%25B0%2f%25EC%25A0%2580%25EC%259E%25A5%25ED%2595%2598%25EA%25B8%25B0%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ARM 어셈블리 튜토리얼 (5) 여러 값 불러오기/저장하기 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fdeguru22.github.io%2f2022%2f05%2f08%2farm-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25ED%258A%259C%25ED%2586%25A0%25EB%25A6%25AC%25EC%2596%25BC-5-%25EC%2597%25AC%25EB%259F%25AC-%25EA%25B0%2592-%25EB%25B6%2588%25EB%259F%25AC%25EC%2598%25A4%25EA%25B8%25B0%2f%25EC%25A0%2580%25EC%259E%25A5%25ED%2595%2598%25EA%25B8%25B0%2f&title=ARM%20%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%20%ed%8a%9c%ed%86%a0%eb%a6%ac%ec%96%bc%20%285%29%20%ec%97%ac%eb%9f%ac%20%ea%b0%92%20%eb%b6%88%eb%9f%ac%ec%98%a4%ea%b8%b0%2f%ec%a0%80%ec%9e%a5%ed%95%98%ea%b8%b0"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ARM 어셈블리 튜토리얼 (5) 여러 값 불러오기/저장하기 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fdeguru22.github.io%2f2022%2f05%2f08%2farm-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25ED%258A%259C%25ED%2586%25A0%25EB%25A6%25AC%25EC%2596%25BC-5-%25EC%2597%25AC%25EB%259F%25AC-%25EA%25B0%2592-%25EB%25B6%2588%25EB%259F%25AC%25EC%2598%25A4%25EA%25B8%25B0%2f%25EC%25A0%2580%25EC%259E%25A5%25ED%2595%2598%25EA%25B8%25B0%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ARM 어셈블리 튜토리얼 (5) 여러 값 불러오기/저장하기 on whatsapp" href="https://api.whatsapp.com/send?text=ARM%20%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%20%ed%8a%9c%ed%86%a0%eb%a6%ac%ec%96%bc%20%285%29%20%ec%97%ac%eb%9f%ac%20%ea%b0%92%20%eb%b6%88%eb%9f%ac%ec%98%a4%ea%b8%b0%2f%ec%a0%80%ec%9e%a5%ed%95%98%ea%b8%b0%20-%20https%3a%2f%2fdeguru22.github.io%2f2022%2f05%2f08%2farm-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25ED%258A%259C%25ED%2586%25A0%25EB%25A6%25AC%25EC%2596%25BC-5-%25EC%2597%25AC%25EB%259F%25AC-%25EA%25B0%2592-%25EB%25B6%2588%25EB%259F%25AC%25EC%2598%25A4%25EA%25B8%25B0%2f%25EC%25A0%2580%25EC%259E%25A5%25ED%2595%2598%25EA%25B8%25B0%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ARM 어셈블리 튜토리얼 (5) 여러 값 불러오기/저장하기 on telegram" href="https://telegram.me/share/url?text=ARM%20%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%20%ed%8a%9c%ed%86%a0%eb%a6%ac%ec%96%bc%20%285%29%20%ec%97%ac%eb%9f%ac%20%ea%b0%92%20%eb%b6%88%eb%9f%ac%ec%98%a4%ea%b8%b0%2f%ec%a0%80%ec%9e%a5%ed%95%98%ea%b8%b0&url=https%3a%2f%2fdeguru22.github.io%2f2022%2f05%2f08%2farm-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25ED%258A%259C%25ED%2586%25A0%25EB%25A6%25AC%25EC%2596%25BC-5-%25EC%2597%25AC%25EB%259F%25AC-%25EA%25B0%2592-%25EB%25B6%2588%25EB%259F%25AC%25EC%2598%25A4%25EA%25B8%25B0%2f%25EC%25A0%2580%25EC%259E%25A5%25ED%2595%2598%25EA%25B8%25B0%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=deguru22/deguru22.github.io issue-term=url label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=https://deguru22.github.io/>데구루루x2 놀이터</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>