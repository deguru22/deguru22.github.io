<!doctype html><html lang=kr><meta charset=utf-8>
<meta name=viewport content="width=device-width">
<title>ARM 어셈 튜토리얼 (2) 데이터 타입과 레지스터 | 데구루루x2 놀이터</title>
<meta name=generator content="Hugo Eureka 0.8.2">
<link rel=stylesheet href=/css/eureka.min.css>
<script defer src=/js/eureka.min.js></script>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin>
<link rel=preload href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap" as=style onload="this.onload=null,this.rel='stylesheet'">
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/styles/solarized-light.min.css media=print onload="this.media='all',this.onload=null" crossorigin>
<script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/highlight.min.js crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/languages/dart.min.js crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/js/all.min.js integrity="sha256-uNYoXefWRqv+PsIF/OflNmwtKM4lStn9yrz2gVl6ymo=" crossorigin></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X media=print onload="this.media='all',this.onload=null" crossorigin>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script>
<script defer src=https://cdn.jsdelivr.net/npm/mermaid@8.9.2/dist/mermaid.min.js integrity="sha256-Zmpaaj+GXFsPF5WdPArSrnW3b30dovldeKsW00xBVwE=" crossorigin></script>
<link rel=preconnect href=https://www.google-analytics.com crossorigin>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-164568875-1"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','UA-164568875-1')</script>
<link rel=icon type=image/png sizes=32x32 href=/images/deguru22_hufc063740f6f81162e489d60dbe402c0f_388931_32x32_fill_q75_box_center.jpg>
<link rel=apple-touch-icon sizes=180x180 href=/images/deguru22_hufc063740f6f81162e489d60dbe402c0f_388931_180x180_fill_q75_box_center.jpg>
<meta name=description content="ARM 어셈블리 기본 내용">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"/kr/posts/"},{"@type":"ListItem","position":2,"name":"ARM 어셈 튜토리얼 (2) 데이터 타입과 레지스터","item":"/kr/2021/08/18/arm-%EC%96%B4%EC%85%88-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-2-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85%EA%B3%BC-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"/kr/2021/08/18/arm-%EC%96%B4%EC%85%88-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-2-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85%EA%B3%BC-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0/"},"headline":"ARM 어셈 튜토리얼 (2) 데이터 타입과 레지스터 | 데구루루x2 놀이터","datePublished":"2021-08-18T23:44:56+09:00","dateModified":"2021-08-18T23:44:56+09:00","wordCount":3691,"publisher":{"@type":"Person","name":"deguru22","logo":{"@type":"ImageObject","url":"/images/deguru22.jpg"}},"description":"ARM 어셈블리 기본 내용"}</script><meta property="og:title" content="ARM 어셈 튜토리얼 (2) 데이터 타입과 레지스터 | 데구루루x2 놀이터">
<meta property="og:type" content="article">
<meta property="og:image" content="/images/deguru22.jpg">
<meta property="og:url" content="/kr/2021/08/18/arm-%EC%96%B4%EC%85%88-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-2-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85%EA%B3%BC-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0/">
<meta property="og:description" content="ARM 어셈블리 기본 내용">
<meta property="og:locale" content="kr">
<meta property="og:site_name" content="데구루루x2 놀이터">
<meta property="article:published_time" content="2021-08-18T23:44:56+09:00">
<meta property="article:modified_time" content="2021-08-18T23:44:56+09:00">
<meta property="article:section" content="posts">
<body class="flex flex-col min-h-screen">
<header class="fixed flex items-center w-full min-h-16 pl-scrollbar z-50 bg-secondary-bg shadow-sm">
<div class="w-full max-w-screen-xl mx-auto"><script>let storageColorScheme=localStorage.getItem("lightDarkMode");((storageColorScheme=='Auto'||storageColorScheme==null)&&window.matchMedia("(prefers-color-scheme: dark)").matches||storageColorScheme=="Dark")&&document.getElementsByTagName('html')[0].classList.add('dark')</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
<a href=/kr class="mr-6 text-primary-text text-xl font-bold">데구루루x2 놀이터</a>
<button id=navbar-btn class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
<i class="fas fa-bars"></i>
</button>
<div id=target class="hidden block md:flex md:flex-grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
<div class="md:flex md:h-16 text-sm md:flex-grow pb-4 md:pb-0 border-b md:border-b-0">
<a href=/kr/#about class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent mr-4">About</a>
<a href=/kr/posts/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent mr-4">Posts</a>
</div>
<div class=flex>
<div class="relative pt-4 md:pt-0">
<div class="cursor-pointer hover:text-eureka" id=lightDarkMode>
<i class="fas fa-adjust"></i>
</div>
<div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id=is-open>
</div>
<div class="absolute flex flex-col left-0 md:left-auto right-auto md:right-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40" id=lightDarkOptions>
<span class="px-4 py-1 hover:text-eureka" name=Light></span>
<span class="px-4 py-1 hover:text-eureka" name=Dark></span>
<span class="px-4 py-1 hover:text-eureka" name=Auto></span>
</div>
</div>
</div>
</div>
<div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id=is-open-mobile>
</div>
</nav>
<script>let element=document.getElementById('lightDarkMode');storageColorScheme==null||storageColorScheme=='Auto'?document.addEventListener('DOMContentLoaded',()=>{window.matchMedia("(prefers-color-scheme: dark)").addEventListener('change',switchDarkMode)}):storageColorScheme=="Light"?(element.firstElementChild.classList.remove('fa-adjust'),element.firstElementChild.setAttribute("data-icon",'sun'),element.firstElementChild.classList.add('fa-sun')):storageColorScheme=="Dark"&&(element.firstElementChild.classList.remove('fa-adjust'),element.firstElementChild.setAttribute("data-icon",'moon'),element.firstElementChild.classList.add('fa-moon')),document.addEventListener('DOMContentLoaded',()=>{getcolorscheme(),switchBurger()})</script>
</div>
</header>
<main class="flex-grow pt-16">
<div class=pl-scrollbar>
<div class="w-full max-w-screen-xl lg:px-4 xl:px-8 mx-auto">
<div class="grid grid-cols-2 lg:grid-cols-8 gap-4 lg:pt-12">
<div class="col-span-2 lg:col-span-6 bg-secondary-bg rounded px-6 py-8">
<h1 class="font-bold text-3xl text-primary-text">ARM 어셈 튜토리얼 (2) 데이터 타입과 레지스터</h1>
<div class="flex flex-wrap flex-row items-center mt-2 text-tertiary-text">
<div class="mr-6 my-2">
<i class="fas fa-calendar mr-1"></i>
<span>2021-08-18</span>
</div>
<div class="mr-6 my-2">
<i class="fas fa-clock mr-1"></i>
<span></span>
</div>
<div class="mr-6 my-2">
<i class="fas fa-folder mr-1"></i>
<a href=/kr/categories/arm/ class=hover:text-eureka>ARM</a>
<span>, </span>
<a href=/kr/categories/assembly/ class=hover:text-eureka>Assembly</a>
<span>, </span>
<a href=/kr/categories/tutorial/ class=hover:text-eureka>Tutorial</a>
</div>
</div>
<div class=content>
<p>ARM Assembly에 대해 공부하던 중 좋은 글이 있어 번역 하였다.</p>
<p>출처: Azeria Labs (<a href=https://azeria-labs.com/writing-arm-assembly-part-2/>https://azeria-labs.com/writing-arm-assembly-part-1/</a>)</p>
<hr>
<h2 id=데이터-타입들>데이터 타입들</h2>
<p><img src=ARM%20Assembly%20Basics%203134602edfb547cf9d4bef69e63a3045/Untitled.png alt=ARM%20Assembly%20Basics%203134602edfb547cf9d4bef69e63a3045/Untitled.png></p>
<p>하이레벨 언어들과 비슷하게, ARM은 다른 데이터타입에 대한 연산을 지원합니다. 우리가 불러오거나 저장할 수 있는 데이터 타입들은 부호가 없는 워드(unsigned words), 반 워드(half words), 혹은 바이트(bytes) 입니다. 이 데이터 타입들에 대해 붙는 전치사(익스텐션)들은: <code>-h or -sh: halfwords</code>, <code>-b or -sb: bytes</code>이며 워드(words)는 익스텐션이 없습니다. 부호가 있는(signed) 것과 없는(unsigned)것의 차이는 아래와 같습니다.</p>
<ul>
<li>부호가 있는 데이터 타입들은 양수와 음수를 모두 저장할 수 있으므로, 표현할 수 있는 범위(range)가 적습니다.</li>
<li>부호가 없는 데이터 타입은 0을 포함한 큰 양수를 저장할 수 있지만 음수를 저장할 수 없으므로, 표현할 수 있는 범위가 넓습니다.</li>
</ul>
<p>아래에 데이터 타입들이 실제 명령어로 어떻게 사용되는지 예제를 참고해 주세요.</p>
<pre><code class=language-jsx>ldr = Load Word
ldr**h** = Load unsigned Half Word
ldr**sh** = Load signed Half Word
ldr**b** = Load unsigned Byte
ldr**sb** = Load signed Bytes

str = Store Word
str**h** = Store unsigned Half Word
str**sh** = Store signed Half Word
str**b** = Store unsigned Byte
str**sb** = Store signed Byte
</code></pre>
<h2 id=엔디안endianness>엔디안(Endianness)</h2>
<p>메모리에서 바이트를 읽는 두 가지 방법이 있습니다: 리틀엔디안(Little-Endian, LE)과 빅엔디안(Big-Endian, BE). 두개의 차이는 메모리에 저장될 때 쓰는 방식입니다(번역자의 코멘트: 한국어와 아랍어의 읽는 방식 차이라고 생각하면 쉽습니다). 리틀 엔디안을 사용하는 인텔 x86 기계들의 경우 가장 낮은 바이트(least-significant-byte)가 낮은 주소에 저장됩니다. ARM 아키텍쳐는 버전 3 이전에는 리틀 엔디안을 사용했지만, 그 이후로는 바이 엔디안(bi-endian)을 사용하는데, 그말인 즉슨 엔디안을 상호 변환할 수 있다는 겁니다. ARMv6의 경우를 예를 들면, 명령어들은 고정된 리틀 엔디안을 사용하고 데이터 접근 시에는 리틀 엔디안 혹은 빅 엔디안을 프로그램 상태 레지스터(Program Status Register, CPSR)의 비트 9, E 비트를 사용해서 읽어올 수 있습니다.</p>
<p><img src=ARM%20Assembly%20Basics%203134602edfb547cf9d4bef69e63a3045/Untitled%201.png alt=ARM%20Assembly%20Basics%203134602edfb547cf9d4bef69e63a3045/Untitled%201.png></p>
<h2 id=arm-레지스터>ARM 레지스터</h2>
<p>레지스터의 갯수는 ARM 버전에 따라 달라집니다. ARM 레퍼런스 메뉴얼에 따르면, 30개의 일반 목적의 32-bit 레지스터가 있습니다(ARMv6-M과 ARMv7-M 기반의 프로세서는 예외로 합니다). 첫 16개의 레지스터는 사용자 레벨 모드에서 접근 가능하며, 추가 레지스터들은 권한 상승된 소프트웨어 실행 시(ARMv6-M과 ARMv70M 기반의 프로세서 에서는 예외로 합니다) 접근할 수 있습니다. 이 튜토리얼에서는 우리는 권한 상승된 모드에서 접근 가능한 r0-15 레지스터에 대해 배울 것입니다. 이 16개의 레지스터는 2개의 그룹으로 나뉠 수 있습니다: 일반 목적의 레지스터(R0-R11)와 특수 목적의 레지스터(R12-R15).</p>
<p><a href=https://www.notion.so/a1f0785c3f514d15907957162c7413f8>레지스터 종류 및 용도</a></p>
<p>아래 표에 인텔 프로세서와 ARM 레지스터를 간단하게 비교해 두었습니다.</p>
<p><a href=https://www.notion.so/d723a4dcf9e641e7b9410e05d63eb8f8>ARM vs Intel(x86)</a></p>
<p><strong>R0-R12:</strong> 일반적인 명령 처리 중 임시 값, 포인터(메모리 주소) 등을 저장할 때 사용합니다. 예를 들어 R0는 숫자 연산 작업 중 이전 명령의 결과를 임시로 저장할 때 사용합니다. R7은 syscall(시스템 명령 호출) 번호를 저장하는데 사용하고, R11은 스택의 범위를 추적하여 프레임 포인터로 사용합니다(추후 상세 설명 예정 입니다). 추가적으로, ARM의 함수 호출 컨벤션상 첫 4개의 인자값은 r0-r3 레지스터에 저장하도록 규정하고 있습니다.</p>
<p><strong>R13: SP(스택 포인터).</strong> 스택 포인터는 스택의 가장 높은 곳을 가르킵니다. 스택은 메모리 영역 중 특정 함수의 저장 공간으로 사용되며, 함수 실행이 종료되면 반환됩니다. 그러므로 스택 포인터는 스택 내 공간을 할당하는데 사용하며, 공간 할당 시에는 가지고 있는 포인터에서 할당을 원하는 용량 만큼을 뺍니다. 우리가 32-bit 만큼을 할당하고 싶다면, 스택 포인터에서 4를 빼면 됩니다.</p>
<p><strong>R14: LR(링크 레지스터).</strong> 함수 호출이 이루어 질 때 링크 레지스터는 명령이 실행된 곳에서 다음에 실행할 명령어의 메모리 주소를 가리킵니다. 이렇게 함으로서 호출된 자식 함수로부터 최초 호출한 부모 함수로 되돌아 갔을때 다음에 실행할 명령을 확인할 수 있습니다.</p>
<p><strong>R15: PC(프로그램 카운터).</strong> 프로그램 카운터는 명령이 실행되면 자동으로 특정 크기만큼 증가합니다. ARM 상태에서는 4바이트 증가하고, THUMB 모드에서는 2바이트 증가합니다. 분기 명령이 실행 되었을 경우, PC는 목적지 주소를 저장합니다. 명령 실행 동안에 ARM 상태에서 PC는 현재 명령어 더하기 8 (두개의 ARM 명령어) 의 주소를 저장하고 있고, THUMB(v1) 상태에서는 더하기 4 (두개의 THUMB 명령어) 한 주소값을 저장하고 있습니다. 이 점이 바로 다음 명령어 위치를 가리키는 x86과의 다른점입니다.</p>
<p>어떻게 PC가 디버거에서 작동하는지 보겠습니다. 아래 프로그램은 PC의 주소를 r0에 저장하고 두 개의 랜덤 명령을 포함하고 있습니다. 어떤일이 일어나는지 확인해 봅시다.</p>
<pre><code class=language-jsx>.section .text
.global _start

_start:
  mov r0, pc
  mov r1, #2
  add r2, r1, r1
  bkpt
</code></pre>
<p>GDB에서 우리가 breakpoint를 _start에 걸고 아래와 같이 실행합니다.</p>
<pre><code class=language-jsx>gef&gt; br _start
Breakpoint 1 at 0x8054
gef&gt; run
</code></pre>
<p>실행 후 우리가 처음 보는 결과물은 아래와 같습니다.</p>
<pre><code class=language-jsx>$r0 0x00000000   $r1 0x00000000   $r2 0x00000000   $r3 0x00000000 
$r4 0x00000000   $r5 0x00000000   $r6 0x00000000   $r7 0x00000000 
$r8 0x00000000   $r9 0x00000000   $r10 0x00000000  $r11 0x00000000 
$r12 0x00000000  $sp 0xbefff7e0   $lr 0x00000000   **$pc 0x00008054** 
$cpsr 0x00000010 

**0x8054 &lt;_start&gt; mov r0, pc     &lt;- $pc**
0x8058 &lt;_start+4&gt; mov r0, #2
0x805c &lt;_start+8&gt; add r1, r0, r0
0x8060 &lt;_start+12&gt; bkpt 0x0000
0x8064 andeq r1, r0, r1, asr #10
0x8068 cmnvs r5, r0, lsl #2
0x806c tsteq r0, r2, ror #18
0x8070 andeq r0, r0, r11
0x8074 tsteq r8, r6, lsl #6
</code></pre>
<p>위에서 우리는 PC가 다음에 실행할 명령(mov r0, pc)의 메모리 주소(0x8054)를 가지고 있음을 알고 있습니다. 이제 명령을 실행하면 r0가 PC(0x8054)의 주소를 가지고 있어야 합니다. 맞죠? 아래에서 결과를 확인해 봅시다.</p>
<pre><code class=language-jsx>**$r0 0x0000805c**   $r1 0x00000000   $r2 0x00000000   $r3 0x00000000 
$r4 0x00000000   $r5 0x00000000   $r6 0x00000000   $r7 0x00000000 
$r8 0x00000000   $r9 0x00000000   $r10 0x00000000  $r11 0x00000000 
$r12 0x00000000  $sp 0xbefff7e0   $lr 0x00000000   **$pc 0x00008058** 
$cpsr 0x00000010

**0x8058 &lt;_start+4&gt; mov r0, #2       &lt;- $pc**
0x805c &lt;_start+8&gt; add r1, r0, r0
0x8060 &lt;_start+12&gt; bkpt 0x0000
0x8064 andeq r1, r0, r1, asr #10
0x8068 cmnvs r5, r0, lsl #2
0x806c tsteq r0, r2, ror #18
0x8070 andeq r0, r0, r11
0x8074 tsteq r8, r6, lsl #6
0x8078 adfcssp f0, f0, #4.0
</code></pre>
<p>&mldr;맞나요? 아뇨 틀렸습니다. R0에 있는 값을 보세요. 우리는 R0에 전에 미리 읽어놨던 $pc의 값(0x8054) 일것이라고 생각했는데, 우리가 전에 읽었던 실제로는 PC로부터 2 명령어가 지난 값(0x805c)을 저장하고 있습니다. 이 예제를 통해 우리가 직접 PC를 읽을 경우 PC는 바로 다음 명령을 가리킨다는 것을 알 수 있습니다. 그렇지만 디버깅을 해 보면, PC는 현재 PC값에서 다음 두 번째 명령어 위치 (0x8054 + 0x8 = 0x805C)를 가리킨다는 것을 알 수 있습니다. ARM이 이런식으로 만들어져 있는 이유는 이전 세대의 프로세서와의 호환성을 위해서 입니다.</p>
<h2 id=현재-프로그램-상태-레지스터-cpsr>현재 프로그램 상태 레지스터 (CPSR)</h2>
<p>gdb를 사용해서 ARM 바이너리를 디버깅 해 보면, 가끔 아래와 같은 플래그(Flags)를 볼 수 있습니다.</p>
<p><img src=ARM%20Assembly%20Basics%203134602edfb547cf9d4bef69e63a3045/Untitled%202.png alt=ARM%20Assembly%20Basics%203134602edfb547cf9d4bef69e63a3045/Untitled%202.png></p>
<p>레지스터 $cpsr는 현재 프로그램 상태 레지스터(Current Program Status Register, CPSR) 값을 보여주며, 해당 값을 통해 플래그 - thumb, fast, interrupt, overflow, carry, zero, negative - 를 확인할 수 있습니다. 이 플래그들은 CPSR 레지스터 내의 특정 위치의 비트 값을 통해 활성화 여부를 확인할 수 있습니다. N, Z, C, V 비트들은 x86에서 사용하는 EFLAG 레지스터의 SF, ZF, CF, OF 비트와 동일합니다. 이 비트들은 조건문 혹은 반복문을 어셈블리 레벨에서 서포트 해주는 역할을 합니다. 조건문 코드는 Part 6. 조건문 실행 및 분기 에서 다룰 예정입니다.</p>
<p><img src=ARM%20Assembly%20Basics%203134602edfb547cf9d4bef69e63a3045/Untitled%203.png alt=ARM%20Assembly%20Basics%203134602edfb547cf9d4bef69e63a3045/Untitled%203.png></p>
<p>위 사진은 32-bit CPSR 레지스터의 레이아웃을 표시하며, 왼쪽편이 최상위비트(most-significant-bits)이며 오른쪽이 최하위비트(least-significant-bits) 입니다. GE와 M 섹션 및 빈 공간 제외하고 모든 각각의 셀은 1비트 크기를 나타냅니다. 각각의 비트들은 현재 상태를 표현하는데 사용됩니다.</p>
<p><a href=https://www.notion.so/01ceeb27ee3b4f058d5e017938fca3ca>CPSR 값 설명</a></p>
<p>만약 우리가 CMP 명령을 통해 1과 2를 비교한다고 생각해 봅시다. 결과는 &ldquo;마이너스(negative)&rdquo; 일 것입니다 - 왜냐하면 1 - 2 = -1 이니까요. 우리가 동일한 숫자 두개를 비교할 때, 예를들면 2와 2를 비교한다고 가정해 보면, Z (Zero) 플래그가 설정됩니다. 왜냐하면 2 - 2 = 0 이기 때문이죠. 다만 CMP 명령에 사용되는 레지스터들은 수정할 수 없으며, CSPR이 각각의 레지스터를 비교한 결과를 스스로 수정한다는 사실을 명심하세요.</p>
<p>이제 GDB에서(GEF가 설치 된 상태에서) 우리가 r1과 r0을 비교했을 때, r1=4이고 r0=2 일 때, 어떻게 보여지는지 확인해 보겠습니다. 실행 결과는 아래와 같습니다:</p>
<p><img src=ARM%20Assembly%20Basics%203134602edfb547cf9d4bef69e63a3045/Untitled%204.png alt=ARM%20Assembly%20Basics%203134602edfb547cf9d4bef69e63a3045/Untitled%204.png></p>
<p>CARRY 플래그가 설정된 것을 볼 수 있습니다. 왜냐하면 우리는 <code>cmp r1, r0</code> 명령을 통해 r1=4, r0=2를 비교했고, 4-2=2 이기 때문입니다. 이에 반해, negative 플래그(N)은 설정되지 않았는데 왜냐하면 큰 숫자(4)와 작은 숫자(2)를 비교했기 때문입니다. 만약 우리가 <code>cmp r0, r1</code> 명령을 사용했다면 negative 플래그가 활성화 되었을 것입니다.</p>
<p>아래에 <a href=http://infocenter.arm.com/help/topic/com.arm.doc.kui0100a/armasm_chdijedg.htm>ARM Infocenter</a>에 명시된 내용을 발췌해 보았습니다:</p>
<ul>
<li>N - 명령어 실행 결과가 음수일 때 활성화</li>
<li>Z - 명령어 실행 결과가 0일때 활성화</li>
<li>C - 명령어 실행 결과 캐리(carry)가 생길 경우 활성화</li>
<li>V - 명령어 실행 결과 오버플로우가 생길 경우 활성화</li>
</ul>
<p>캐리가 생기는 경우는 아래와 같습니다:</p>
<ul>
<li>덧셈을 한 결과값이 2^32 보다 크거나 같을 때</li>
<li>뺄셈을 한 결과값이 양수이거나 0일 때</li>
<li>move나 논리 명령 실행 중 실행된 인라인 배럴 시프터(inline barrel shifter) 명령의 결과</li>
</ul>
<p>(참고) 인라인 베럴 시프터(inline barrel shifter) 명령이란?</p>
<ul>
<li>ARM 산술 논리 장치에는 시프트 및 회전 작업이 가능한 32 비트 배럴 시프터가 있습니다. 여러 ARM 및 Thumb 데이터 처리 및 단일 레지스터 데이터 전송 명령어에 대한 두 번째 피연산자는 데이터 처리 또는 데이터 전송이 명령어의 일부로 실행되기 전에 이동 될 수 있습니다. <a href=https://www.keil.com/support/man/docs/armasm/armasm_dom1359731140200.htm>(참고)</a></li>
<li>복잡한 명령어들을 처리할 때 사용합니다.</li>
</ul>
<p>오버플로우는 덧셈, 뺄셈, 비교의 결과값이 2^31 보다 같거나 혹은 크거나, -2^31보다 작을 때 발생합니다.</p>
</div>
<div class="flex flex-col md:flex-row md:justify-between -mx-2 mt-4 px-2 pt-4 border-t">
<div>
<span class="block font-bold"></span>
<a href=/kr/2021/08/18/arm-%EC%96%B4%EC%85%88-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-1-%EA%B8%B0%EC%B4%88/ class=block>ARM 어셈 튜토리얼 (1) 기초</a>
</div>
<div class="md:text-right mt-4 md:mt-0">
<span class="block font-bold"></span>
<a href=/kr/2021/07/18/%EC%95%88%EB%85%95/ class=block>안녕!</a>
</div>
</div>
<div id=disqus_thread></div>
<script>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//deguru22-notes.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</div>
<div class=col-span-2>
<div class="sticky top-16 z-10 hidden lg:block px-6 py-4 bg-primary-bg">
<span class="text-lg font-semibold"></span>
</div>
<div class="sticky-toc hidden lg:block px-6 pb-6">
<nav id=TableOfContents>
<ul>
<li><a href=#데이터-타입들>데이터 타입들</a></li>
<li><a href=#엔디안endianness>엔디안(Endianness)</a></li>
<li><a href=#arm-레지스터>ARM 레지스터</a></li>
<li><a href=#현재-프로그램-상태-레지스터-cpsr>현재 프로그램 상태 레지스터 (CPSR)</a></li>
</ul>
</nav>
</div>
<script>window.addEventListener('DOMContentLoaded',()=>{enableStickyToc()})</script>
</div>
</div>
<script>document.addEventListener('DOMContentLoaded',()=>{hljs.initHighlightingOnLoad()})</script>
</div>
</div>
</main>
<footer class=pl-scrollbar>
<div class="w-full max-w-screen-xl mx-auto"><div class="text-center p-6 pin-b">
<p class="text-sm text-tertiary-text">&copy; 2021 deguru22
&#183; Powered by the <a href=https://github.com/wangchucheng/hugo-eureka class=hover:text-eureka>Eureka</a> theme for <a href=https://gohugo.io class=hover:text-eureka>Hugo</a></p>
</div></div>
</footer>
</body>
</html>